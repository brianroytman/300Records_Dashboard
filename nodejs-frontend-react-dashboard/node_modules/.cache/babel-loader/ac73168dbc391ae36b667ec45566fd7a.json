{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.base.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _uiSchedulerAppointmentsPositioningStrategy = require(\"./ui.scheduler.appointmentsPositioning.strategy.base\");\n\nvar _uiSchedulerAppointmentsPositioningStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsPositioningStrategy);\n\nvar _uiSchedulerAppointmentsPositioningStrategy3 = require(\"./ui.scheduler.appointmentsPositioning.strategy.adaptive\");\n\nvar _uiSchedulerAppointmentsPositioningStrategy4 = _interopRequireDefault(_uiSchedulerAppointmentsPositioningStrategy3);\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _ui = require(\"../../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _themes = require(\"../../themes\");\n\nvar _themes2 = _interopRequireDefault(_themes);\n\nvar _utils = require(\"../utils.timeZone\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar toMs = _date2.default.dateToMilliseconds;\nvar APPOINTMENT_MIN_SIZE = 2;\nvar APPOINTMENT_DEFAULT_HEIGHT = 20;\nvar COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT = 18;\nvar DROP_DOWN_BUTTON_ADAPTIVE_SIZE = 28;\n\nvar BaseRenderingStrategy = function () {\n  function BaseRenderingStrategy(instance) {\n    _classCallCheck(this, BaseRenderingStrategy);\n\n    this.instance = instance;\n\n    this._initPositioningStrategy();\n  }\n\n  _createClass(BaseRenderingStrategy, [{\n    key: \"_isAdaptive\",\n    value: function value() {\n      return this.instance.fire(\"isAdaptive\");\n    }\n  }, {\n    key: \"_correctCollectorCoordinatesInAdaptive\",\n    value: function value(coordinates, isAllDay) {\n      coordinates.top = coordinates.top + this.getCollectorTopOffset(isAllDay);\n      coordinates.left = coordinates.left + this.getCollectorLeftOffset();\n    }\n  }, {\n    key: \"_initPositioningStrategy\",\n    value: function value() {\n      this._positioningStrategy = this._isAdaptive() ? new _uiSchedulerAppointmentsPositioningStrategy4.default(this) : new _uiSchedulerAppointmentsPositioningStrategy2.default(this);\n    }\n  }, {\n    key: \"getPositioningStrategy\",\n    value: function value() {\n      return this._positioningStrategy;\n    }\n  }, {\n    key: \"getAppointmentMinSize\",\n    value: function value() {\n      return APPOINTMENT_MIN_SIZE;\n    }\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"getDeltaTime\",\n    value: function value() {}\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(coordinates) {\n      return coordinates;\n    }\n  }, {\n    key: \"needCorrectAppointmentDates\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function value() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function value(items) {\n      delete this._maxAppointmentCountPerCell;\n      var length = items && items.length;\n\n      if (!length) {\n        return;\n      }\n\n      this._defaultWidth = this.instance._cellWidth;\n      this._defaultHeight = this.instance._cellHeight;\n      this._allDayHeight = this.instance._allDayCellHeight;\n      var map = [];\n\n      for (var i = 0; i < length; i++) {\n        var coordinates = this._getItemPosition(items[i]);\n\n        if (this._isRtl()) {\n          coordinates = this._correctRtlCoordinates(coordinates);\n        }\n\n        map.push(coordinates);\n      }\n\n      var positionArray = this._getSortedPositions(map);\n\n      var resultPositions = this._getResultPositions(positionArray);\n\n      return this._getExtendedPositionMap(map, resultPositions);\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function value(args, initialSize) {\n      var intervalWidth = this.instance.fire(\"getResizableStep\") || this.getAppointmentMinSize();\n      var initialWidth = initialSize.width;\n      return Math.round((args.width - initialWidth) / intervalWidth);\n    }\n  }, {\n    key: \"_correctRtlCoordinates\",\n    value: function value(coordinates) {\n      var width = coordinates[0].width || this._getAppointmentMaxWidth();\n\n      coordinates.forEach(function (coordinate) {\n        if (!coordinate.appointmentReduced) {\n          coordinate.left -= width;\n        }\n      });\n      return coordinates;\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth();\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function value(item) {\n      var position = this._getAppointmentCoordinates(item);\n\n      var allDay = this.isAllDay(item);\n      var result = [];\n      var startDate = new Date(this.instance.fire(\"getField\", \"startDate\", item));\n      var isRecurring = !!this.instance.fire(\"getField\", \"recurrenceRule\", item);\n\n      for (var j = 0; j < position.length; j++) {\n        var height = this.calculateAppointmentHeight(item, position[j], isRecurring);\n        var width = this.calculateAppointmentWidth(item, position[j], isRecurring);\n        var resultWidth = width;\n        var appointmentReduced = null;\n        var multiWeekAppointmentParts = [];\n        var initialRowIndex = position[j].rowIndex;\n        var initialCellIndex = position[j].cellIndex;\n\n        if (this._needVerifyItemSize() || allDay) {\n          var currentMaxAllowedPosition = position[j].hMax;\n\n          if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {\n            left: position[j].left,\n            width: width\n          })) {\n            appointmentReduced = \"head\";\n            initialRowIndex = position[j].rowIndex;\n            initialCellIndex = position[j].cellIndex;\n            resultWidth = this._reduceMultiWeekAppointment(width, {\n              left: position[j].left,\n              right: currentMaxAllowedPosition\n            });\n            multiWeekAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentWidth: width,\n              reducedWidth: resultWidth,\n              height: height\n            }, position[j], startDate);\n\n            if (this._isRtl()) {\n              position[j].left = currentMaxAllowedPosition;\n            }\n          }\n        }\n\n        (0, _extend.extend)(position[j], {\n          height: height,\n          width: resultWidth,\n          allDay: allDay,\n          rowIndex: initialRowIndex,\n          cellIndex: initialCellIndex,\n          appointmentReduced: appointmentReduced,\n          originalAppointmentStartDate: this.startDate(item, true),\n          originalAppointmentEndDate: this.endDate(item),\n          endDate: this.endDate(item, position[j], isRecurring)\n        });\n        result = this._getAppointmentPartsPosition(multiWeekAppointmentParts, position[j], result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getAppointmentPartsPosition\",\n    value: function value(appointmentParts, position, result) {\n      if (appointmentParts.length) {\n        appointmentParts.unshift(position);\n        result = result.concat(appointmentParts);\n      } else {\n        result.push(position);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getAppointmentCoordinates\",\n    value: function value(itemData) {\n      return this.instance.fire(\"needCoordinates\", {\n        startDate: this.startDate(itemData),\n        originalStartDate: this.startDate(itemData, true),\n        appointmentData: itemData\n      });\n    }\n  }, {\n    key: \"_isRtl\",\n    value: function value() {\n      return this.instance.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value() {\n      return [];\n    }\n  }, {\n    key: \"_getCompactAppointmentParts\",\n    value: function value(appointmentWidth) {\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      return Math.round(appointmentWidth / cellWidth);\n    }\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function value(sourceAppointmentWidth, bound) {\n      if (this._isRtl()) {\n        sourceAppointmentWidth = Math.floor(bound.left - bound.right);\n      } else {\n        sourceAppointmentWidth = bound.right - Math.floor(bound.left);\n      }\n\n      return sourceAppointmentWidth;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function value(etalon, comparisonParameters) {\n      var result = comparisonParameters.left + comparisonParameters.width - etalon;\n\n      if (this._isRtl()) {\n        result = etalon + comparisonParameters.width - comparisonParameters.left;\n      }\n\n      return result > this.getDefaultCellWidth() / 2;\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"cropAppointmentWidth\",\n    value: function value(width, cellWidth) {\n      if (this.instance.fire(\"isGroupedByDate\")) {\n        width = cellWidth;\n      }\n\n      return width;\n    }\n  }, {\n    key: \"_getSortedPositions\",\n    value: function value(positionList) {\n      var _this = this;\n\n      var result = [];\n\n      var round = function round(value) {\n        return Math.round(100 * value) / 100;\n      };\n\n      var createItem = function createItem(rowIndex, cellIndex, top, left, bottom, right, position, allDay) {\n        return {\n          i: rowIndex,\n          j: cellIndex,\n          top: round(top),\n          left: round(left),\n          bottom: round(bottom),\n          right: round(right),\n          cellPosition: position,\n          allDay: allDay\n        };\n      };\n\n      for (var rowIndex = 0, rowCount = positionList.length; rowIndex < rowCount; rowIndex++) {\n        for (var cellIndex = 0, cellCount = positionList[rowIndex].length; cellIndex < cellCount; cellIndex++) {\n          var _positionList$rowInde = positionList[rowIndex][cellIndex],\n              top = _positionList$rowInde.top,\n              left = _positionList$rowInde.left,\n              height = _positionList$rowInde.height,\n              width = _positionList$rowInde.width,\n              cellPosition = _positionList$rowInde.cellPosition,\n              allDay = _positionList$rowInde.allDay;\n          result.push(createItem(rowIndex, cellIndex, top, left, top + height, left + width, cellPosition, allDay));\n        }\n      }\n\n      return result.sort(function (a, b) {\n        return _this._sortCondition(a, b);\n      });\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value() {}\n  }, {\n    key: \"_getConditions\",\n    value: function value(a, b) {\n      var isSomeEdge = this._isSomeEdge(a, b);\n\n      return {\n        columnCondition: isSomeEdge || this._normalizeCondition(a.left, b.left),\n        rowCondition: isSomeEdge || this._normalizeCondition(a.top, b.top),\n        cellPositionCondition: isSomeEdge || this._normalizeCondition(a.cellPosition, b.cellPosition)\n      };\n    }\n  }, {\n    key: \"_rowCondition\",\n    value: function value(a, b) {\n      var conditions = this._getConditions(a, b);\n\n      return conditions.columnCondition || conditions.rowCondition;\n    }\n  }, {\n    key: \"_columnCondition\",\n    value: function value(a, b) {\n      var conditions = this._getConditions(a, b);\n\n      return conditions.rowCondition || conditions.columnCondition;\n    }\n  }, {\n    key: \"_isSomeEdge\",\n    value: function value(a, b) {\n      return a.i === b.i && a.j === b.j;\n    }\n  }, {\n    key: \"_normalizeCondition\",\n    value: function value(first, second) {\n      var result = first - second;\n      return Math.abs(result) > 1 ? result : 0;\n    }\n  }, {\n    key: \"_isItemsCross\",\n    value: function value(firstItem, secondItem) {\n      var areItemsInTheSameTable = !!firstItem.allDay === !!secondItem.allDay;\n      var areItemsAllDay = firstItem.allDay && secondItem.allDay;\n\n      if (areItemsInTheSameTable) {\n        var orientation = this._getOrientation(areItemsAllDay);\n\n        return this._checkItemsCrossing(firstItem, secondItem, orientation);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_checkItemsCrossing\",\n    value: function value(firstItem, secondItem, orientation) {\n      var firstItemSide_1 = Math.floor(firstItem[orientation[0]]);\n      var firstItemSide_2 = Math.floor(firstItem[orientation[1]]);\n      var secondItemSide_1 = Math.ceil(secondItem[orientation[0]]);\n      var secondItemSide_2 = Math.ceil(secondItem[orientation[1]]);\n      var isItemCross = Math.abs(firstItem[orientation[2]] - secondItem[orientation[2]]) <= 1;\n      return isItemCross && (firstItemSide_1 <= secondItemSide_1 && firstItemSide_2 > secondItemSide_1 || firstItemSide_1 < secondItemSide_2 && firstItemSide_2 >= secondItemSide_2 || firstItemSide_1 === secondItemSide_1 && firstItemSide_2 === secondItemSide_2);\n    }\n  }, {\n    key: \"_getOrientation\",\n    value: function value(isAllDay) {\n      return isAllDay ? [\"left\", \"right\", \"top\"] : [\"top\", \"bottom\", \"left\"];\n    }\n  }, {\n    key: \"_getResultPositions\",\n    value: function value(sortedArray) {\n      var _this2 = this;\n\n      var result = [];\n      var i;\n      var sortedIndex = 0;\n      var currentItem;\n      var indexes;\n      var itemIndex;\n      var maxIndexInStack = 0;\n      var stack = {};\n\n      var findFreeIndex = function findFreeIndex(indexes, index) {\n        var isFind = indexes.some(function (item) {\n          return item === index;\n        });\n\n        if (isFind) {\n          return findFreeIndex(indexes, ++index);\n        } else {\n          return index;\n        }\n      };\n\n      var createItem = function createItem(currentItem, index) {\n        var currentIndex = index || 0;\n        return {\n          index: currentIndex,\n          i: currentItem.i,\n          j: currentItem.j,\n          left: currentItem.left,\n          right: currentItem.right,\n          top: currentItem.top,\n          bottom: currentItem.bottom,\n          allDay: currentItem.allDay,\n          sortedIndex: _this2._skipSortedIndex(currentIndex) ? null : sortedIndex++\n        };\n      };\n\n      var startNewStack = function startNewStack(currentItem) {\n        stack.items = [createItem(currentItem)];\n        stack.left = currentItem.left;\n        stack.right = currentItem.right;\n        stack.top = currentItem.top;\n        stack.bottom = currentItem.bottom;\n        stack.allDay = currentItem.allDay;\n      };\n\n      var pushItemsInResult = function pushItemsInResult(items) {\n        items.forEach(function (item) {\n          result.push({\n            index: item.index,\n            count: maxIndexInStack + 1,\n            i: item.i,\n            j: item.j,\n            sortedIndex: item.sortedIndex\n          });\n        });\n      };\n\n      for (i = 0; i < sortedArray.length; i++) {\n        currentItem = sortedArray[i];\n        indexes = [];\n\n        if (!stack.items) {\n          startNewStack(currentItem);\n        } else {\n          if (this._isItemsCross(stack, currentItem)) {\n            stack.items.forEach(function (item, index) {\n              if (_this2._isItemsCross(item, currentItem)) {\n                indexes.push(item.index);\n              }\n            });\n            itemIndex = indexes.length ? findFreeIndex(indexes, 0) : 0;\n            stack.items.push(createItem(currentItem, itemIndex));\n            maxIndexInStack = Math.max(itemIndex, maxIndexInStack);\n            stack.left = Math.min(stack.left, currentItem.left);\n            stack.right = Math.max(stack.right, currentItem.right);\n            stack.top = Math.min(stack.top, currentItem.top);\n            stack.bottom = Math.max(stack.bottom, currentItem.bottom);\n            stack.allDay = currentItem.allDay;\n          } else {\n            pushItemsInResult(stack.items);\n            stack = {};\n            startNewStack(currentItem);\n            maxIndexInStack = 0;\n          }\n        }\n      }\n\n      if (stack.items) {\n        pushItemsInResult(stack.items);\n      }\n\n      return result.sort(function (a, b) {\n        var columnCondition = a.j - b.j;\n        var rowCondition = a.i - b.i;\n        return rowCondition ? rowCondition : columnCondition;\n      });\n    }\n  }, {\n    key: \"_skipSortedIndex\",\n    value: function value(index) {\n      return index > this._getMaxAppointmentCountPerCell() - 1;\n    }\n  }, {\n    key: \"_findIndexByKey\",\n    value: function value(arr, iKey, jKey, iValue, jValue) {\n      var result = 0;\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i][iKey] === iValue && arr[i][jKey] === jValue) {\n          result = i;\n          break;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getExtendedPositionMap\",\n    value: function value(map, positions) {\n      var positionCounter = 0;\n      var result = [];\n\n      for (var i = 0, mapLength = map.length; i < mapLength; i++) {\n        var resultString = [];\n\n        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {\n          map[i][j].index = positions[positionCounter].index;\n          map[i][j].sortedIndex = positions[positionCounter].sortedIndex;\n          map[i][j].count = positions[positionCounter++].count;\n          resultString.push(map[i][j]);\n\n          this._checkLongCompactAppointment(map[i][j], resultString);\n        }\n\n        result.push(resultString);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkLongCompactAppointment\",\n    value: function value(item, result) {\n      this._splitLongCompactAppointment(item, result);\n\n      return result;\n    }\n  }, {\n    key: \"_splitLongCompactAppointment\",\n    value: function value(item, result) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCellByType(item.allDay);\n\n      var compactCount = 0;\n\n      if (void 0 !== appointmentCountPerCell && item.index > appointmentCountPerCell - 1) {\n        item.isCompact = true;\n        compactCount = this._getCompactAppointmentParts(item.width);\n\n        for (var k = 1; k < compactCount; k++) {\n          var compactPart = (0, _extend.extend)(true, {}, item);\n          compactPart.left = this._getCompactLeftCoordinate(item.left, k);\n          compactPart.cellIndex = compactPart.cellIndex + k;\n          compactPart.sortedIndex = null;\n          result.push(compactPart);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"startDate\",\n    value: function startDate(appointment, skipNormalize, position) {\n      var startDate = position && position.startDate;\n\n      var rangeStartDate = this.instance._getStartDate(appointment, skipNormalize);\n\n      var text = this.instance.fire(\"getField\", \"text\", appointment);\n\n      if (startDate && rangeStartDate > startDate || !startDate) {\n        startDate = rangeStartDate;\n      }\n\n      if (isNaN(startDate.getTime())) {\n        throw _ui2.default.Error(\"E1032\", text);\n      }\n\n      return startDate;\n    }\n  }, {\n    key: \"endDate\",\n    value: function endDate(appointment, position, isRecurring) {\n      var ignoreViewDates = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n\n      var endDate = this.instance._getEndDate(appointment, ignoreViewDates);\n\n      var realStartDate = this.startDate(appointment, true);\n      var viewStartDate = this.startDate(appointment, false, position);\n\n      if (viewStartDate.getTime() > endDate.getTime() || isRecurring) {\n        var recurrencePartStartDate = position ? position.initialStartDate || position.startDate : realStartDate;\n        var recurrencePartCroppedByViewStartDate = position ? position.startDate : realStartDate;\n        var fullDuration = viewStartDate.getTime() > endDate.getTime() ? this.instance.fire(\"getField\", \"endDate\", appointment).getTime() - this.instance.fire(\"getField\", \"startDate\", appointment).getTime() : endDate.getTime() - realStartDate.getTime();\n        fullDuration = this._adjustDurationByDaylightDiff(fullDuration, realStartDate, endDate);\n        endDate = new Date(viewStartDate.getTime() >= recurrencePartStartDate.getTime() ? recurrencePartStartDate.getTime() : viewStartDate.getTime());\n\n        if (isRecurring) {\n          endDate = new Date(endDate.getTime() + fullDuration);\n        }\n\n        if (!_date2.default.sameDate(realStartDate, endDate) && recurrencePartCroppedByViewStartDate.getTime() < viewStartDate.getTime()) {\n          var headDuration = _date2.default.trimTime(endDate).getTime() - recurrencePartCroppedByViewStartDate.getTime();\n          var tailDuration = fullDuration - headDuration || fullDuration;\n          endDate = new Date(_date2.default.trimTime(viewStartDate).getTime() + tailDuration);\n        }\n      }\n\n      if (!this.isAllDay(appointment)) {\n        var viewEndDate = _date2.default.roundToHour(this.instance.fire(\"getEndViewDate\"));\n\n        if (endDate > viewEndDate) {\n          endDate = viewEndDate;\n        }\n      }\n\n      var currentViewEndTime = new Date(new Date(endDate).setHours(this.instance.option(\"endDayHour\"), 0, 0));\n\n      if (endDate.getTime() > currentViewEndTime.getTime()) {\n        endDate = currentViewEndTime;\n      }\n\n      return endDate;\n    }\n  }, {\n    key: \"_adjustDurationByDaylightDiff\",\n    value: function value(duration, startDate, endDate) {\n      var daylightDiff = _utils2.default.getDaylightOffset(startDate, endDate);\n\n      return this._needAdjustDuration(daylightDiff) ? this._calculateDurationByDaylightDiff(duration, daylightDiff) : duration;\n    }\n  }, {\n    key: \"_needAdjustDuration\",\n    value: function value(diff) {\n      return 0 !== diff;\n    }\n  }, {\n    key: \"_calculateDurationByDaylightDiff\",\n    value: function value(duration, diff) {\n      return duration + diff * toMs(\"minute\");\n    }\n  }, {\n    key: \"_getAppointmentDurationInMs\",\n    value: function value(startDate, endDate, allDay) {\n      return this.instance.fire(\"getAppointmentDurationInMs\", {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay\n      });\n    }\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function value(coordinates, isAllDay) {\n      var countFullWidthAppointmentInCell = this._getMaxAppointmentCountPerCellByType(isAllDay);\n\n      if (coordinates.count - countFullWidthAppointmentInCell > 0) {\n        coordinates.virtual = {\n          top: coordinates.top,\n          left: coordinates.left,\n          index: \"tail\" === coordinates.appointmentReduced ? coordinates.groupIndex + \"-\" + coordinates.rowIndex + \"-\" + coordinates.cellIndex : coordinates.groupIndex + \"-\" + coordinates.rowIndex + \"-\" + coordinates.cellIndex + \"-tail\",\n          isAllDay: isAllDay\n        };\n      }\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCellByType\",\n    value: function value(isAllDay) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCell();\n\n      if (_type2.default.isObject(appointmentCountPerCell)) {\n        return isAllDay ? this._getMaxAppointmentCountPerCell().allDay : this._getMaxAppointmentCountPerCell().simple;\n      } else {\n        return appointmentCountPerCell;\n      }\n    }\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function value(intervalCount, isAllDay) {\n      return this.getPositioningStrategy().getDropDownAppointmentWidth(intervalCount, isAllDay);\n    }\n  }, {\n    key: \"getDropDownAppointmentHeight\",\n    value: function value() {\n      return this.getPositioningStrategy().getDropDownAppointmentHeight();\n    }\n  }, {\n    key: \"getDropDownButtonAdaptiveSize\",\n    value: function value() {\n      return DROP_DOWN_BUTTON_ADAPTIVE_SIZE;\n    }\n  }, {\n    key: \"getDefaultCellWidth\",\n    value: function value() {\n      return this._defaultWidth;\n    }\n  }, {\n    key: \"getDefaultCellHeight\",\n    value: function value() {\n      return this._defaultHeight;\n    }\n  }, {\n    key: \"getDefaultAllDayCellHeight\",\n    value: function value() {\n      return this._allDayHeight;\n    }\n  }, {\n    key: \"getCollectorTopOffset\",\n    value: function value(allDay) {\n      return this.getPositioningStrategy().getCollectorTopOffset(allDay);\n    }\n  }, {\n    key: \"getCollectorLeftOffset\",\n    value: function value() {\n      return this.getPositioningStrategy().getCollectorLeftOffset();\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function value() {}\n  }, {\n    key: \"_customizeCoordinates\",\n    value: function value(coordinates, height, appointmentCountPerCell, topOffset, isAllDay) {\n      var index = coordinates.index;\n      var appointmentHeight = height / appointmentCountPerCell;\n      var appointmentTop = coordinates.top + index * appointmentHeight;\n      var top = appointmentTop + topOffset;\n      var width = coordinates.width;\n      var left = coordinates.left;\n\n      if (coordinates.isCompact) {\n        this._isAdaptive() && this._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);\n\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: appointmentHeight,\n        width: width,\n        top: top,\n        left: left,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_isAppointmentEmpty\",\n    value: function value(height, width) {\n      return height < this._getAppointmentMinHeight() || width < this._getAppointmentMinWidth();\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      var offsets = this._getOffsets();\n\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxHeight = this._getMaxHeight();\n\n      if (!(0, _type.isNumeric)(appointmentCountPerCell)) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxHeight - offsets.unlimited) / maxHeight;\n      }\n\n      var topOffset = (1 - ratio) * maxHeight;\n\n      if (\"auto\" === overlappingMode || (0, _type.isNumeric)(overlappingMode)) {\n        ratio = 1;\n        maxHeight -= appointmentDefaultOffset;\n        topOffset = appointmentDefaultOffset;\n      }\n\n      return {\n        height: ratio * maxHeight,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function value() {}\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function value() {}\n  }, {\n    key: \"_getOffsets\",\n    value: function value() {}\n  }, {\n    key: \"_getMaxHeight\",\n    value: function value() {}\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"needSeparateAppointment\",\n    value: function value(allDay) {\n      return this.instance.fire(\"isGroupedByDate\") && allDay;\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCell\",\n    value: function value() {\n      if (!this._maxAppointmentCountPerCell) {\n        var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n        var appointmentCountPerCell;\n\n        if ((0, _type.isNumeric)(overlappingMode)) {\n          appointmentCountPerCell = overlappingMode;\n        }\n\n        if (\"auto\" === overlappingMode) {\n          appointmentCountPerCell = this._getDynamicAppointmentCountPerCell();\n        }\n\n        if (\"unlimited\" === overlappingMode) {\n          appointmentCountPerCell = void 0;\n        }\n\n        this._maxAppointmentCountPerCell = appointmentCountPerCell;\n      }\n\n      return this._maxAppointmentCountPerCell;\n    }\n  }, {\n    key: \"_getDynamicAppointmentCountPerCell\",\n    value: function value() {\n      return this.getPositioningStrategy().getDynamicAppointmentCountPerCell();\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_isCompactTheme\",\n    value: function value() {\n      return \"compact\" === (_themes2.default.current() || \"\").split(\".\").pop();\n    }\n  }, {\n    key: \"_getAppointmentDefaultOffset\",\n    value: function value() {\n      return this.getPositioningStrategy().getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"_getAppointmentDefaultHeight\",\n    value: function value() {\n      return this._getAppointmentHeightByTheme();\n    }\n  }, {\n    key: \"_getAppointmentMinHeight\",\n    value: function value() {\n      return this._getAppointmentDefaultHeight();\n    }\n  }, {\n    key: \"_getAppointmentHeightByTheme\",\n    value: function value() {\n      return this._isCompactTheme() ? COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT : APPOINTMENT_DEFAULT_HEIGHT;\n    }\n  }, {\n    key: \"_getAppointmentDefaultWidth\",\n    value: function value() {\n      return this.getPositioningStrategy()._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_getAppointmentMinWidth\",\n    value: function value() {\n      return this._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }]);\n\n  return BaseRenderingStrategy;\n}();\n\nmodule.exports = BaseRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}