{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/ui.scheduler.appointment_model.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _config = require(\"../../core/config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _date_serialization = require(\"../../core/utils/date_serialization\");\n\nvar _date_serialization2 = _interopRequireDefault(_date_serialization);\n\nvar _utils = require(\"./utils.recurrence\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _query = require(\"../../data/query\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar toMs = _date2.default.dateToMilliseconds;\nvar DATE_FILTER_POSITION = 0;\nvar USER_FILTER_POSITION = 1;\n\nvar FilterMaker = function () {\n  function FilterMaker(dataAccessors) {\n    _classCallCheck(this, FilterMaker);\n\n    this._filterRegistry = null;\n    this._dataAccessors = dataAccessors;\n  }\n\n  _createClass(FilterMaker, [{\n    key: \"isRegistered\",\n    value: function value() {\n      return !!this._filterRegistry;\n    }\n  }, {\n    key: \"clearRegistry\",\n    value: function value() {\n      delete this._filterRegistry;\n    }\n  }, {\n    key: \"make\",\n    value: function value(type, args) {\n      if (!this._filterRegistry) {\n        this._filterRegistry = {};\n      }\n\n      this._make(type).apply(this, args);\n    }\n  }, {\n    key: \"_make\",\n    value: function value(type) {\n      var _this = this;\n\n      switch (type) {\n        case \"date\":\n          return function (min, max, useAccessors) {\n            var startDate = useAccessors ? _this._dataAccessors.getter.startDate : _this._dataAccessors.expr.startDateExpr;\n            var endDate = useAccessors ? _this._dataAccessors.getter.endDate : _this._dataAccessors.expr.endDateExpr;\n            var recurrenceRule = _this._dataAccessors.expr.recurrenceRuleExpr;\n            _this._filterRegistry.date = [[[endDate, \">\", min], [startDate, \"<\", max]], \"or\", [recurrenceRule, \"startswith\", \"freq\"], \"or\", [[endDate, min], [startDate, min]]];\n\n            if (!recurrenceRule) {\n              _this._filterRegistry.date.splice(1, 2);\n            }\n          };\n\n        case \"user\":\n          return function (userFilter) {\n            _this._filterRegistry.user = userFilter;\n          };\n      }\n    }\n  }, {\n    key: \"combine\",\n    value: function value() {\n      var filter = [];\n      this._filterRegistry.date && filter.push(this._filterRegistry.date);\n      this._filterRegistry.user && filter.push(this._filterRegistry.user);\n      return filter;\n    }\n  }, {\n    key: \"dateFilter\",\n    value: function value() {\n      return this._filterRegistry.date;\n    }\n  }]);\n\n  return FilterMaker;\n}();\n\nvar compareDateWithStartDayHour = function compareDateWithStartDayHour(startDate, endDate, startDayHour, allDay, severalDays) {\n  var startTime = _date2.default.dateTimeFromDecimal(startDayHour);\n\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\n\nvar compareDateWithEndDayHour = function compareDateWithEndDayHour(startDate, endDate, startDayHour, endDayHour, allDay, severalDays, max, min) {\n  var hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n\n  var endTime = _date2.default.dateTimeFromDecimal(endDayHour);\n\n  var startTime = _date2.default.dateTimeFromDecimal(startDayHour);\n\n  result = apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && startDate < max && endDate > min && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\n\nvar AppointmentModel = function () {\n  function AppointmentModel(dataSource, dataAccessors, baseAppointmentDuration) {\n    _classCallCheck(this, AppointmentModel);\n\n    this.setDataAccessors(dataAccessors);\n    this.setDataSource(dataSource);\n    this._updatedAppointmentKeys = [];\n    this._filterMaker = new FilterMaker(dataAccessors);\n    this._baseAppointmentDuration = baseAppointmentDuration;\n  }\n\n  _createClass(AppointmentModel, [{\n    key: \"_createFilter\",\n    value: function value(min, max, remoteFiltering, dateSerializationFormat) {\n      this._filterMaker.make(\"date\", [min, max]);\n\n      var userFilterPosition = this._excessFiltering() ? this._dataSource.filter()[USER_FILTER_POSITION] : this._dataSource.filter();\n\n      this._filterMaker.make(\"user\", [userFilterPosition]);\n\n      if (remoteFiltering) {\n        this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n      }\n    }\n  }, {\n    key: \"_excessFiltering\",\n    value: function value() {\n      var dateFilter = this._filterMaker.dateFilter();\n\n      var dataSourceFilter = this._dataSource.filter();\n\n      return dataSourceFilter && ((0, _common.equalByValue)(dataSourceFilter, dateFilter) || dataSourceFilter.length && (0, _common.equalByValue)(dataSourceFilter[DATE_FILTER_POSITION], dateFilter));\n    }\n  }, {\n    key: \"_combineFilter\",\n    value: function value() {\n      return this._filterMaker.combine();\n    }\n  }, {\n    key: \"_getStoreKey\",\n    value: function value(target) {\n      var store = this._dataSource.store();\n\n      return store.keyOf(target);\n    }\n  }, {\n    key: \"_filterAppointmentByResources\",\n    value: function value(appointment, resources) {\n      var _this2 = this;\n\n      var result = false;\n      var i;\n      var len;\n      var resourceName;\n\n      var checkAppointmentResourceValues = function checkAppointmentResourceValues() {\n        var resourceGetter = _this2._dataAccessors.getter.resources[resourceName];\n        var resource;\n\n        if (_type2.default.isFunction(resourceGetter)) {\n          resource = resourceGetter(appointment);\n        }\n\n        var appointmentResourceValues = _array2.default.wrapToArray(resource);\n\n        var resourceData = _iterator2.default.map(resources[i].items, function (item) {\n          return item.id;\n        });\n\n        for (var j = 0, itemDataCount = appointmentResourceValues.length; j < itemDataCount; j++) {\n          if ((0, _array.inArray)(appointmentResourceValues[j], resourceData) > -1) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      for (i = 0, len = resources.length; i < len; i++) {\n        resourceName = resources[i].name;\n        result = checkAppointmentResourceValues.call(this);\n\n        if (!result) {\n          return false;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_filterAppointmentByRRule\",\n    value: function value(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n      var recurrenceRule = appointment.recurrenceRule;\n      var recurrenceException = appointment.recurrenceException;\n      var allDay = appointment.allDay;\n      var result = true;\n      var appointmentStartDate = appointment.startDate;\n      var appointmentEndDate = appointment.endDate;\n\n      if (allDay || this._appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n        var trimmedDates = this._trimDates(min, max);\n\n        min = trimmedDates.min;\n        max = new Date(trimmedDates.max.getTime() - toMs(\"minute\"));\n      }\n\n      if (recurrenceRule && !_utils2.default.getRecurrenceRule(recurrenceRule).isValid) {\n        result = appointmentEndDate > min && appointmentStartDate <= max;\n      }\n\n      if (result && _utils2.default.getRecurrenceRule(recurrenceRule).isValid) {\n        result = _utils2.default.dateInRecurrenceRange({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: appointmentStartDate,\n          end: appointmentEndDate,\n          min: min,\n          max: max,\n          firstDayOfWeek: firstDayOfWeek\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_appointmentPartInInterval\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      var apptStartDayHour = startDate.getHours();\n      var apptEndDayHour = endDate.getHours();\n      return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n    }\n  }, {\n    key: \"_createCombinedFilter\",\n    value: function value(filterOptions, timeZoneProcessor) {\n      var dataAccessors = this._dataAccessors;\n      var startDayHour = filterOptions.startDayHour;\n      var endDayHour = filterOptions.endDayHour;\n      var min = new Date(filterOptions.min);\n      var max = new Date(filterOptions.max);\n      var resources = filterOptions.resources;\n      var firstDayOfWeek = filterOptions.firstDayOfWeek;\n      var getRecurrenceException = filterOptions.recurrenceException;\n      var that = this;\n      return [[function (appointment) {\n        var result = true;\n        var startDate = new Date(dataAccessors.getter.startDate(appointment));\n        var endDate = new Date(dataAccessors.getter.endDate(appointment));\n        var appointmentTakesAllDay = that.appointmentTakesAllDay(appointment, startDayHour, endDayHour);\n        var appointmentTakesSeveralDays = that.appointmentTakesSeveralDays(appointment);\n        var isAllDay = dataAccessors.getter.allDay(appointment);\n        var appointmentIsLong = appointmentTakesSeveralDays || appointmentTakesAllDay;\n\n        var useRecurrence = _type2.default.isDefined(dataAccessors.getter.recurrenceRule);\n\n        var recurrenceRule;\n\n        if (useRecurrence) {\n          recurrenceRule = dataAccessors.getter.recurrenceRule(appointment);\n        }\n\n        if (resources && resources.length) {\n          result = that._filterAppointmentByResources(appointment, resources);\n        }\n\n        if (appointmentTakesAllDay && false === filterOptions.allDay) {\n          result = false;\n        }\n\n        var startDateTimeZone = dataAccessors.getter.startDateTimeZone(appointment);\n        var endDateTimeZone = dataAccessors.getter.endDateTimeZone(appointment);\n        var comparableStartDate = timeZoneProcessor(startDate, startDateTimeZone);\n        var comparableEndDate = timeZoneProcessor(endDate, endDateTimeZone);\n\n        if (result && useRecurrence) {\n          var recurrenceException = getRecurrenceException ? getRecurrenceException(appointment) : dataAccessors.getter.recurrenceException(appointment);\n          result = that._filterAppointmentByRRule({\n            startDate: comparableStartDate,\n            endDate: comparableEndDate,\n            recurrenceRule: recurrenceRule,\n            recurrenceException: recurrenceException,\n            allDay: appointmentTakesAllDay\n          }, min, max, startDayHour, endDayHour, firstDayOfWeek);\n        }\n\n        if (result && comparableEndDate < min && appointmentIsLong && !isAllDay && (!useRecurrence || useRecurrence && !recurrenceRule)) {\n          result = false;\n        }\n\n        if (result && void 0 !== startDayHour) {\n          result = compareDateWithStartDayHour(comparableStartDate, comparableEndDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays);\n        }\n\n        if (result && void 0 !== endDayHour) {\n          result = compareDateWithEndDayHour(comparableStartDate, comparableEndDate, startDayHour, endDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays, max, min);\n        }\n\n        if (result && useRecurrence && !recurrenceRule) {\n          if (comparableEndDate < min && !isAllDay) {\n            result = false;\n          }\n        }\n\n        return result;\n      }]];\n    }\n  }, {\n    key: \"setDataSource\",\n    value: function value(dataSource) {\n      this._dataSource = dataSource;\n      this.cleanModelState();\n\n      this._initStoreChangeHandlers();\n\n      this._filterMaker && this._filterMaker.clearRegistry();\n    }\n  }, {\n    key: \"_initStoreChangeHandlers\",\n    value: function value() {\n      var _this3 = this;\n\n      var dataSource = this._dataSource;\n      var store = null === dataSource || void 0 === dataSource ? void 0 : dataSource.store();\n\n      if (store) {\n        store.on(\"updating\", function (newItem) {\n          _this3._updatedAppointment = newItem;\n        });\n        store.on(\"push\", function (pushItems) {\n          var items = dataSource.items();\n          var keyName = store.key();\n          pushItems.forEach(function (pushItem) {\n            var itemExists = 0 !== items.filter(function (item) {\n              return item[keyName] === pushItem.key;\n            }).length;\n\n            if (itemExists) {\n              _this3._updatedAppointmentKeys.push({\n                key: keyName,\n                value: pushItem.key\n              });\n            } else {\n              items.push(pushItem.data);\n            }\n          });\n        });\n      }\n    }\n  }, {\n    key: \"getUpdatedAppointment\",\n    value: function value() {\n      return this._updatedAppointment;\n    }\n  }, {\n    key: \"getUpdatedAppointmentKeys\",\n    value: function value() {\n      return this._updatedAppointmentKeys;\n    }\n  }, {\n    key: \"cleanModelState\",\n    value: function value() {\n      this._updatedAppointment = null;\n      this._updatedAppointmentKeys = [];\n    }\n  }, {\n    key: \"setDataAccessors\",\n    value: function value(dataAccessors) {\n      this._dataAccessors = dataAccessors;\n      this._filterMaker = new FilterMaker(dataAccessors);\n    }\n  }, {\n    key: \"filterByDate\",\n    value: function value(min, max, remoteFiltering, dateSerializationFormat) {\n      if (!this._dataSource) {\n        return;\n      }\n\n      var trimmedDates = this._trimDates(min, max);\n\n      if (!this._filterMaker.isRegistered()) {\n        this._createFilter(trimmedDates.min, trimmedDates.max, remoteFiltering, dateSerializationFormat);\n      } else {\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max]);\n\n        if (this._dataSource.filter() && this._dataSource.filter().length > 1) {\n          var userFilter = this._serializeRemoteFilter([this._dataSource.filter()[1]], dateSerializationFormat);\n\n          this._filterMaker.make(\"user\", userFilter);\n        }\n\n        if (remoteFiltering) {\n          this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n        }\n      }\n    }\n  }, {\n    key: \"_combineRemoteFilter\",\n    value: function value(dateSerializationFormat) {\n      var combinedFilter = this._filterMaker.combine();\n\n      return this._serializeRemoteFilter(combinedFilter, dateSerializationFormat);\n    }\n  }, {\n    key: \"_serializeRemoteFilter\",\n    value: function value(filter, dateSerializationFormat) {\n      if (!Array.isArray(filter)) {\n        return filter;\n      }\n\n      filter = (0, _extend.extend)([], filter);\n      var startDate = this._dataAccessors.expr.startDateExpr;\n      var endDate = this._dataAccessors.expr.endDateExpr;\n\n      if (_type2.default.isString(filter[0])) {\n        if ((0, _config2.default)().forceIsoDateParsing && filter.length > 1) {\n          if (filter[0] === startDate || filter[0] === endDate) {\n            filter[filter.length - 1] = _date_serialization2.default.serializeDate(new Date(filter[filter.length - 1]), dateSerializationFormat);\n          }\n        }\n      }\n\n      for (var i = 0; i < filter.length; i++) {\n        filter[i] = this._serializeRemoteFilter(filter[i], dateSerializationFormat);\n      }\n\n      return filter;\n    }\n  }, {\n    key: \"filterLoadedAppointments\",\n    value: function value(filterOptions, timeZoneProcessor) {\n      if (!_type2.default.isFunction(timeZoneProcessor)) {\n        timeZoneProcessor = function timeZoneProcessor(date) {\n          return date;\n        };\n      }\n\n      var combinedFilter = this._createCombinedFilter(filterOptions, timeZoneProcessor);\n\n      if (this._filterMaker.isRegistered()) {\n        this._filterMaker.make(\"user\", void 0);\n\n        var trimmedDates = this._trimDates(filterOptions.min, filterOptions.max);\n\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max, true]);\n\n        var dateFilter = this.customizeDateFilter(this._filterMaker.combine(), timeZoneProcessor);\n        combinedFilter.push([dateFilter]);\n      }\n\n      return (0, _query2.default)(this._dataSource.items()).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"_trimDates\",\n    value: function value(min, max) {\n      var minCopy = _date2.default.trimTime(new Date(min));\n\n      var maxCopy = _date2.default.trimTime(new Date(max));\n\n      maxCopy.setDate(maxCopy.getDate() + 1);\n      return {\n        min: minCopy,\n        max: maxCopy\n      };\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value(items, startDayHour, endDayHour) {\n      if (!items) {\n        return false;\n      }\n\n      var that = this;\n      var result = false;\n\n      _iterator2.default.each(items, function (index, item) {\n        if (that.appointmentTakesAllDay(item, startDayHour, endDayHour)) {\n          result = true;\n          return false;\n        }\n      });\n\n      return result;\n    }\n  }, {\n    key: \"appointmentTakesAllDay\",\n    value: function value(appointment, startDayHour, endDayHour) {\n      var dataAccessors = this._dataAccessors;\n      var startDate = dataAccessors.getter.startDate(appointment);\n      var endDate = dataAccessors.getter.endDate(appointment);\n      var allDay = dataAccessors.getter.allDay(appointment);\n      return allDay || this._appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasAllDayDuration\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      startDate = new Date(startDate);\n      endDate = new Date(endDate);\n      var dayDuration = 24;\n\n      var appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate);\n\n      return appointmentDurationInHours >= dayDuration || this._appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasShortDayDuration\",\n    value: function value(startDate, endDate, startDayHour, endDayHour) {\n      var appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate);\n\n      var shortDayDurationInHours = endDayHour - startDayHour;\n      return appointmentDurationInHours >= shortDayDurationInHours && startDate.getHours() === startDayHour && endDate.getHours() === endDayHour;\n    }\n  }, {\n    key: \"_getAppointmentDurationInHours\",\n    value: function value(startDate, endDate) {\n      return (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n    }\n  }, {\n    key: \"appointmentTakesSeveralDays\",\n    value: function value(appointment) {\n      var dataAccessors = this._dataAccessors;\n      var startDate = new Date(dataAccessors.getter.startDate(appointment));\n      var endDate = new Date(dataAccessors.getter.endDate(appointment));\n      return !_date2.default.sameDate(startDate, endDate);\n    }\n  }, {\n    key: \"customizeDateFilter\",\n    value: function value(dateFilter, timeZoneProcessor) {\n      var _this4 = this;\n\n      var currentFilter = (0, _extend.extend)(true, [], dateFilter);\n      return function (appointment) {\n        var startDate = new Date(_this4._dataAccessors.getter.startDate(appointment));\n        var endDate = new Date(_this4._dataAccessors.getter.endDate(appointment));\n        endDate = _this4.fixWrongEndDate(appointment, startDate, endDate);\n        appointment = (0, _extend.extend)(true, {}, appointment);\n\n        var startDateTimeZone = _this4._dataAccessors.getter.startDateTimeZone(appointment);\n\n        var endDateTimeZone = _this4._dataAccessors.getter.endDateTimeZone(appointment);\n\n        var comparableStartDate = timeZoneProcessor(startDate, startDateTimeZone);\n        var comparableEndDate = timeZoneProcessor(endDate, endDateTimeZone);\n\n        _this4._dataAccessors.setter.startDate(appointment, comparableStartDate);\n\n        _this4._dataAccessors.setter.endDate(appointment, comparableEndDate);\n\n        return (0, _query2.default)([appointment]).filter(currentFilter).toArray().length > 0;\n      }.bind(this);\n    }\n  }, {\n    key: \"fixWrongEndDate\",\n    value: function value(appointment, startDate, endDate) {\n      if (this._isEndDateWrong(startDate, endDate)) {\n        var isAllDay = this._dataAccessors.getter.allDay(appointment);\n\n        endDate = this._calculateAppointmentEndDate(isAllDay, startDate);\n\n        this._dataAccessors.setter.endDate(appointment, endDate);\n      }\n\n      return endDate;\n    }\n  }, {\n    key: \"_calculateAppointmentEndDate\",\n    value: function value(isAllDay, startDate) {\n      if (isAllDay) {\n        return _date2.default.setToDayEnd(new Date(startDate));\n      }\n\n      return new Date(startDate.getTime() + this._baseAppointmentDuration * toMs(\"minute\"));\n    }\n  }, {\n    key: \"_isEndDateWrong\",\n    value: function value(startDate, endDate) {\n      return !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\n    }\n  }, {\n    key: \"add\",\n    value: function value(data, tz) {\n      var _this5 = this;\n\n      return this._dataSource.store().insert(data).done(function () {\n        _this5._dataSource.load();\n      }.bind(this));\n    }\n  }, {\n    key: \"update\",\n    value: function value(target, data) {\n      var _this6 = this;\n\n      var key = this._getStoreKey(target);\n\n      var d = new _deferred.Deferred();\n\n      this._dataSource.store().update(key, data).done(function () {\n        _this6._dataSource.load().done(d.resolve).fail(d.reject);\n      }).fail(d.reject);\n\n      return d.promise();\n    }\n  }, {\n    key: \"remove\",\n    value: function value(target) {\n      var _this7 = this;\n\n      var key = this._getStoreKey(target);\n\n      return this._dataSource.store().remove(key).done(function () {\n        _this7._dataSource.load();\n      }.bind(this));\n    }\n  }]);\n\n  return AppointmentModel;\n}();\n\nmodule.exports = AppointmentModel;","map":null,"metadata":{},"sourceType":"script"}