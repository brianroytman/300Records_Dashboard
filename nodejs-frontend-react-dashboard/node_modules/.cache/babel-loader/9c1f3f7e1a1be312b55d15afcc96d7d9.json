{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/utils.recurrence.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar errors = require(\"../../core/errors\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar inArray = require(\"../../core/utils/array\").inArray;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar dateUtils = require(\"../../core/utils/date\");\n\nvar toMs = dateUtils.dateToMilliseconds;\nvar leastDaysInWeek = 4;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar daysNames = {\n  0: \"SU\",\n  1: \"MO\",\n  2: \"TU\",\n  3: \"WE\",\n  4: \"TH\",\n  5: \"FR\",\n  6: \"SA\"\n};\nvar intervalMap = {\n  secondly: \"seconds\",\n  minutely: \"minutes\",\n  hourly: \"hours\",\n  daily: \"days\",\n  weekly: \"weeks\",\n  monthly: \"months\",\n  yearly: \"years\"\n};\nvar resultUtils = {};\nvar dateSetterMap = {\n  bysecond: function bysecond(date, value) {\n    date.setSeconds(value);\n  },\n  byminute: function byminute(date, value) {\n    date.setMinutes(value);\n  },\n  byhour: function byhour(date, value) {\n    date.setHours(value);\n  },\n  bymonth: function bymonth(date, value) {\n    date.setMonth(value);\n  },\n  bymonthday: function bymonthday(date, value) {\n    if (value < 0) {\n      var initialDate = new Date(date);\n      setDateByNegativeValue(initialDate, 1, -1);\n      var daysInMonth = initialDate.getDate();\n\n      if (daysInMonth >= Math.abs(value)) {\n        setDateByNegativeValue(date, 1, value);\n      } else {\n        setDateByNegativeValue(date, 2, value);\n      }\n    } else {\n      if (value <= dateUtils.getLastMonthDay(date)) {\n        date.setDate(value);\n      } else {\n        markWrongDate(date);\n      }\n    }\n  },\n  byday: function byday(date, byDay, appointmentWeekStart, frequency, firstDayOfWeek) {\n    var appointmentDayOfWeek = date.getDay();\n    var weekStart = days[appointmentWeekStart];\n    byDay += byDay >= weekStart === weekStart > appointmentDayOfWeek ? 7 : 0;\n    date.setDate(date.getDate() - appointmentDayOfWeek + byDay);\n  },\n  byweekno: function byweekno(date, weekNumber, weekStart) {\n    var initialDate = new Date(date);\n    var firstYearDate = new Date(initialDate.setMonth(0, 1));\n    var dayShift = firstYearDate.getDay() - days[weekStart];\n    var firstDayOfYear = firstYearDate.getTime() - dayShift * toMs(\"day\");\n    var newFirstYearDate = dayShift + 1;\n\n    if (newFirstYearDate > leastDaysInWeek) {\n      date.setTime(firstDayOfYear + 7 * weekNumber * toMs(\"day\"));\n    } else {\n      date.setTime(firstDayOfYear + 7 * (weekNumber - 1) * toMs(\"day\"));\n    }\n\n    var timezoneDiff = (date.getTimezoneOffset() - firstYearDate.getTimezoneOffset()) * toMs(\"minute\");\n    timezoneDiff && date.setTime(date.getTime() + timezoneDiff);\n  },\n  byyearday: function byyearday(date, dayOfYear) {\n    date.setMonth(0, 1);\n    date.setDate(dayOfYear);\n  }\n};\n\nfunction setDateByNegativeValue(date, month, value) {\n  var initialDate = new Date(date);\n  date.setMonth(date.getMonth() + month);\n\n  if (date.getMonth() - initialDate.getMonth() > month) {\n    date.setDate(value + 1);\n  }\n\n  date.setDate(value + 1);\n}\n\nvar dateGetterMap = {\n  bysecond: function bysecond(date) {\n    return date.getSeconds();\n  },\n  byminute: function byminute(date) {\n    return date.getMinutes();\n  },\n  byhour: function byhour(date) {\n    return date.getHours();\n  },\n  bymonth: function bymonth(date) {\n    return date.getMonth();\n  },\n  bymonthday: function bymonthday(date) {\n    return date.getDate();\n  },\n  byday: function byday(date) {\n    return date.getDay();\n  },\n  byweekno: function byweekno(date, weekStart) {\n    var current = new Date(date);\n    var diff = leastDaysInWeek - current.getDay() + days[weekStart] - 1;\n    var dayInMilliseconds = toMs(\"day\");\n\n    if (date.getDay() < days[weekStart]) {\n      diff -= 7;\n    }\n\n    current.setHours(0, 0, 0);\n    current.setDate(current.getDate() + diff);\n    var yearStart = new Date(current.getFullYear(), 0, 1);\n    var timezoneDiff = (yearStart.getTimezoneOffset() - current.getTimezoneOffset()) * toMs(\"minute\");\n    var daysFromYearStart = 1 + (current - yearStart + timezoneDiff) / dayInMilliseconds;\n    return Math.ceil(daysFromYearStart / 7);\n  },\n  byyearday: function byyearday(date) {\n    var yearStart = new Date(date.getFullYear(), 0, 0);\n    var timezoneDiff = date.getTimezoneOffset() - yearStart.getTimezoneOffset();\n    var diff = date - yearStart - timezoneDiff * toMs(\"minute\");\n    var dayLength = toMs(\"day\");\n    return Math.floor(diff / dayLength);\n  }\n};\n\nfunction getTimeZoneOffset() {\n  return new Date().getTimezoneOffset();\n}\n\nvar dateInRecurrenceRange = function dateInRecurrenceRange(options) {\n  var result = [];\n\n  if (options.rule) {\n    result = getDatesByRecurrence(options);\n  }\n\n  return !!result.length;\n};\n\nvar normalizeInterval = function normalizeInterval(rule) {\n  var interval = rule.interval;\n  var freq = rule.freq;\n  var intervalObject = {};\n  var intervalField = intervalMap[freq.toLowerCase()];\n\n  if (\"MONTHLY\" === freq && rule.byday) {\n    intervalField = intervalMap.daily;\n  }\n\n  intervalObject[intervalField] = interval;\n  return intervalObject;\n};\n\nvar getDatesByRecurrenceException = function getDatesByRecurrenceException(ruleValues, date) {\n  var result = [];\n\n  for (var i = 0, len = ruleValues.length; i < len; i++) {\n    result[i] = getDateByAsciiString(ruleValues[i], date);\n  }\n\n  return result;\n};\n\nvar dateIsRecurrenceException = function dateIsRecurrenceException(date, recurrenceException) {\n  var result = false;\n\n  if (!recurrenceException) {\n    return result;\n  }\n\n  var splitDates = recurrenceException.split(\",\");\n  var exceptDates = getDatesByRecurrenceException(splitDates, date);\n  var shortFormat = /\\d{8}$/;\n\n  for (var i = 0, len = exceptDates.length; i < len; i++) {\n    if (splitDates[i].match(shortFormat)) {\n      var diffs = getDatePartDiffs(date, exceptDates[i]);\n\n      if (0 === diffs.years && 0 === diffs.months && 0 === diffs.days) {\n        result = true;\n      }\n    } else {\n      if (date.getTime() === exceptDates[i].getTime()) {\n        result = true;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar doNextIteration = function doNextIteration(date, startIntervalDate, endIntervalDate, recurrenceRule, iterationCount) {\n  var matchCountIsCorrect = true;\n  endIntervalDate = endIntervalDate.getTime();\n\n  if (recurrenceRule.until) {\n    if (recurrenceRule.until.getTime() < endIntervalDate) {\n      endIntervalDate = recurrenceRule.until.getTime();\n    }\n  }\n\n  if (recurrenceRule.count) {\n    if (iterationCount === recurrenceRule.count) {\n      matchCountIsCorrect = false;\n    }\n  }\n\n  var dateInInterval = date.getTime() <= endIntervalDate;\n  return dateInInterval && matchCountIsCorrect;\n};\n\nfunction getDatesByRecurrence(options) {\n  var result = [];\n  var recurrenceRule = getRecurrenceRule(options.rule);\n  var iterationResult = {};\n  var rule = recurrenceRule.rule;\n  var recurrenceStartDate = options.start;\n  var maxDate = correctMaxDate(options.max, rule);\n\n  if (!recurrenceRule.isValid || !rule.freq) {\n    return result;\n  }\n\n  rule.interval = normalizeInterval(rule);\n  var dateRules = splitDateRules(rule, options.firstDayOfWeek);\n  var duration = options.end ? options.end.getTime() - options.start.getTime() : toMs(\"day\");\n  var config = {\n    exception: options.exception,\n    min: options.min,\n    dateRules: dateRules,\n    rule: rule,\n    recurrenceStartDate: recurrenceStartDate,\n    recurrenceEndDate: options.end,\n    duration: duration\n  };\n\n  if (dateRules.length && rule.count) {\n    var iteration = 0;\n    getDatesByCount(dateRules, new Date(recurrenceStartDate), new Date(recurrenceStartDate), rule).forEach(function (currentDate, i) {\n      if (currentDate < maxDate) {\n        iteration++;\n        iterationResult = pushToResult(iteration, iterationResult, currentDate, i, config, true);\n      }\n    });\n  } else {\n    getDatesByRules(dateRules, new Date(recurrenceStartDate), rule).forEach(function (currentDate, i) {\n      var iteration = 0;\n\n      while (doNextIteration(currentDate, recurrenceStartDate, maxDate, rule, iteration)) {\n        iteration++;\n        iterationResult = pushToResult(iteration, iterationResult, currentDate, i, config);\n        currentDate = incrementDate(currentDate, recurrenceStartDate, rule, i);\n      }\n    });\n  }\n\n  if (rule.bysetpos) {\n    each(iterationResult, function (iterationIndex, iterationDates) {\n      iterationResult[iterationIndex] = filterDatesBySetPos(iterationDates, rule.bysetpos);\n    });\n  }\n\n  each(iterationResult, function (_, iterationDates) {\n    result = result.concat(iterationDates);\n  });\n  result = result.filter(function (date) {\n    return date <= options.max;\n  });\n  result.sort(function (a, b) {\n    return a - b;\n  });\n  return result;\n}\n\nfunction pushToResult(iteration, iterationResult, currentDate, i, config, verifiedField) {\n  if (!iterationResult[iteration]) {\n    iterationResult[iteration] = [];\n  }\n\n  if (checkDate(currentDate, i, config, verifiedField)) {\n    iterationResult[iteration].push(currentDate);\n  }\n\n  return iterationResult;\n}\n\nfunction checkDate(currentDate, i, config, verifiedField) {\n  if (!dateIsRecurrenceException(currentDate, config.exception)) {\n    var duration = dateUtils.sameDate(currentDate, config.recurrenceEndDate) && config.recurrenceEndDate.getTime() > currentDate.getTime() ? config.recurrenceEndDate.getTime() - currentDate.getTime() : config.duration;\n\n    if (currentDate.getTime() >= config.recurrenceStartDate.getTime() && currentDate.getTime() + duration > config.min.getTime()) {\n      return verifiedField || checkDateByRule(currentDate, [config.dateRules[i]], config.rule.wkst);\n    }\n  }\n\n  return false;\n}\n\nfunction filterDatesBySetPos(dates, bySetPos) {\n  var resultArray = [];\n  bySetPos.split(\",\").forEach(function (index) {\n    index = Number(index);\n    var dateIndex = index > 0 ? index - 1 : dates.length + index;\n\n    if (dates[dateIndex]) {\n      resultArray.push(dates[dateIndex]);\n    }\n  });\n  return resultArray;\n}\n\nfunction correctMaxDate(maxDate, rule) {\n  var newMaxDate = new Date(maxDate);\n\n  switch (rule.freq) {\n    case \"MONTHLY\":\n      newMaxDate.setMonth(newMaxDate.getMonth() + 1);\n      break;\n\n    case \"YEARLY\":\n      newMaxDate.setYear(newMaxDate.getYear() + 1);\n  }\n\n  return newMaxDate > maxDate ? newMaxDate : maxDate;\n}\n\nfunction correctDate(originalDate, date) {\n  if (originalDate.getDate() !== date) {\n    originalDate.setDate(date);\n  }\n}\n\nfunction incrementDate(date, originalStartDate, rule, iterationStep) {\n  var initialDate = new Date(date);\n  var needCorrect = true;\n  date = dateUtils.addInterval(date, rule.interval);\n\n  if (\"DAILY\" === rule.freq && !isDefined(rule.byhour) && originalStartDate.getHours() !== date.getHours()) {\n    date = new Date(date.getTime() - (initialDate.getHours() - originalStartDate.getHours()) * toMs(\"hour\"));\n  }\n\n  if (\"MONTHLY\" === rule.freq && !rule.byday) {\n    var expectedDate = originalStartDate.getDate();\n\n    if (rule.bymonthday) {\n      expectedDate = Number(rule.bymonthday.split(\",\")[iterationStep]);\n\n      if (expectedDate < 0) {\n        initialDate.setMonth(initialDate.getMonth() + 1, 1);\n        dateSetterMap.bymonthday(initialDate, expectedDate);\n        date = initialDate;\n        needCorrect = false;\n      }\n    }\n\n    needCorrect && correctDate(date, expectedDate);\n  }\n\n  if (\"YEARLY\" === rule.freq) {\n    if (rule.byyearday) {\n      var dayNumber = Number(rule.byyearday.split(\",\")[iterationStep]);\n      dateSetterMap.byyearday(date, dayNumber);\n    }\n\n    var dateRules = splitDateRules(rule);\n\n    for (var field in dateRules[iterationStep]) {\n      dateSetterMap[field] && dateSetterMap[field](date, dateRules[iterationStep][field], rule.wkst);\n    }\n  }\n\n  return date;\n}\n\nfunction getDatePartDiffs(date1, date2) {\n  return {\n    years: date1.getFullYear() - date2.getFullYear(),\n    months: date1.getMonth() - date2.getMonth(),\n    days: date1.getDate() - date2.getDate(),\n    hours: date1.getHours() - date2.getHours(),\n    minutes: date1.getMinutes() - date2.getMinutes(),\n    seconds: date1.getSeconds() - date2.getSeconds()\n  };\n}\n\nfunction getRecurrenceRule(recurrence) {\n  var result = {\n    rule: {},\n    isValid: false\n  };\n\n  if (recurrence) {\n    result.rule = parseRecurrenceRule(recurrence);\n    result.isValid = validateRRule(result.rule, recurrence);\n  }\n\n  return result;\n}\n\nvar loggedWarnings = [];\n\nfunction validateRRule(rule, recurrence) {\n  if (brokenRuleNameExists(rule) || inArray(rule.freq, freqNames) === -1 || wrongCountRule(rule) || wrongIntervalRule(rule) || wrongDayOfWeek(rule) || wrongByMonthDayRule(rule) || wrongByMonth(rule) || wrongUntilRule(rule)) {\n    logBrokenRule(recurrence);\n    return false;\n  }\n\n  return true;\n}\n\nfunction wrongUntilRule(rule) {\n  var wrongUntil = false;\n  var until = rule.until;\n\n  if (void 0 !== until && !(until instanceof Date)) {\n    wrongUntil = true;\n  }\n\n  return wrongUntil;\n}\n\nfunction wrongCountRule(rule) {\n  var wrongCount = false;\n  var count = rule.count;\n\n  if (count && \"string\" === typeof count) {\n    wrongCount = true;\n  }\n\n  return wrongCount;\n}\n\nfunction wrongByMonthDayRule(rule) {\n  var wrongByMonthDay = false;\n  var byMonthDay = rule.bymonthday;\n\n  if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n    wrongByMonthDay = true;\n  }\n\n  return wrongByMonthDay;\n}\n\nfunction wrongByMonth(rule) {\n  var wrongByMonth = false;\n  var byMonth = rule.bymonth;\n\n  if (byMonth && isNaN(parseInt(byMonth))) {\n    wrongByMonth = true;\n  }\n\n  return wrongByMonth;\n}\n\nfunction wrongIntervalRule(rule) {\n  var wrongInterval = false;\n  var interval = rule.interval;\n\n  if (interval && \"string\" === typeof interval) {\n    wrongInterval = true;\n  }\n\n  return wrongInterval;\n}\n\nfunction wrongDayOfWeek(rule) {\n  var daysByRule = daysFromByDayRule(rule);\n  var brokenDaysExist = false;\n  each(daysByRule, function (_, day) {\n    if (!Object.prototype.hasOwnProperty.call(days, day)) {\n      brokenDaysExist = true;\n      return false;\n    }\n  });\n  return brokenDaysExist;\n}\n\nfunction brokenRuleNameExists(rule) {\n  var brokenRuleExists = false;\n  each(rule, function (ruleName) {\n    if (inArray(ruleName, ruleNames) === -1) {\n      brokenRuleExists = true;\n      return false;\n    }\n  });\n  return brokenRuleExists;\n}\n\nfunction logBrokenRule(recurrence) {\n  if (inArray(recurrence, loggedWarnings) === -1) {\n    errors.log(\"W0006\", recurrence);\n    loggedWarnings.push(recurrence);\n  }\n}\n\nfunction parseRecurrenceRule(recurrence) {\n  var ruleObject = {};\n  var ruleParts = recurrence.split(\";\");\n\n  for (var i = 0, len = ruleParts.length; i < len; i++) {\n    var rule = ruleParts[i].split(\"=\");\n    var ruleName = rule[0].toLowerCase();\n    var ruleValue = rule[1];\n    ruleObject[ruleName] = ruleValue;\n  }\n\n  var count = parseInt(ruleObject.count);\n\n  if (!isNaN(count)) {\n    ruleObject.count = count;\n  }\n\n  if (ruleObject.interval) {\n    var interval = parseInt(ruleObject.interval);\n\n    if (!isNaN(interval)) {\n      ruleObject.interval = interval;\n    }\n  } else {\n    ruleObject.interval = 1;\n  }\n\n  if (ruleObject.freq && ruleObject.until) {\n    ruleObject.until = getDateByAsciiString(ruleObject.until);\n  }\n\n  return ruleObject;\n}\n\nfunction getDateByAsciiString(string, initialDate) {\n  if (\"string\" !== typeof string) {\n    return string;\n  }\n\n  var arrayDate = string.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n\n  if (!arrayDate) {\n    return null;\n  }\n\n  var isUTC = void 0 !== arrayDate[8];\n  var currentOffset = initialDate ? initialDate.getTimezoneOffset() : resultUtils.getTimeZoneOffset();\n  var date = new (Function.prototype.bind.apply(Date, prepareDateArrayToParse(arrayDate)))();\n  currentOffset = 6e4 * currentOffset;\n\n  if (isUTC) {\n    date = new Date(date.getTime() - currentOffset);\n  }\n\n  return date;\n}\n\nfunction prepareDateArrayToParse(arrayDate) {\n  arrayDate.shift();\n\n  if (void 0 === arrayDate[3]) {\n    arrayDate.splice(3);\n  } else {\n    arrayDate.splice(3, 1);\n    arrayDate.splice(6);\n  }\n\n  arrayDate[1]--;\n  arrayDate.unshift(null);\n  return arrayDate;\n}\n\nfunction daysFromByDayRule(rule) {\n  var result = [];\n\n  if (rule.byday) {\n    if (Array.isArray(rule.byday)) {\n      result = rule.byday;\n    } else {\n      result = rule.byday.split(\",\");\n    }\n  }\n\n  return result;\n}\n\nfunction getAsciiStringByDate(date) {\n  var currentOffset = 6e4 * resultUtils.getTimeZoneOffset();\n  date = new Date(date.getTime() + currentOffset);\n  return date.getFullYear() + (\"0\" + (date.getMonth() + 1)).slice(-2) + (\"0\" + date.getDate()).slice(-2) + \"T\" + (\"0\" + date.getHours()).slice(-2) + (\"0\" + date.getMinutes()).slice(-2) + (\"0\" + date.getSeconds()).slice(-2) + \"Z\";\n}\n\nfunction splitDateRules(rule) {\n  var firstDayOfWeek = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n  var result = [];\n\n  if (isDefined(firstDayOfWeek)) {\n    rule.fdow = firstDayOfWeek;\n  }\n\n  if (!rule.wkst) {\n    rule.wkst = isDefined(firstDayOfWeek) ? daysNames[firstDayOfWeek] : \"MO\";\n  }\n\n  if (rule.byweekno && !rule.byday) {\n    var dayNames = Object.keys(days);\n\n    for (var i = 0; i < days[rule.wkst]; i++) {\n      dayNames.push(dayNames.shift());\n    }\n\n    rule.byday = dayNames.join(\",\");\n  }\n\n  for (var field in dateSetterMap) {\n    if (!rule[field]) {\n      continue;\n    }\n\n    var ruleFieldValues = rule[field].split(\",\");\n    var ruleArray = getDateRuleArray(field, ruleFieldValues);\n    result = result.length ? extendObjectArray(ruleArray, result) : ruleArray;\n  }\n\n  return result;\n}\n\nfunction getDateRuleArray(field, values) {\n  var result = [];\n\n  for (var i = 0, length = values.length; i < length; i++) {\n    var dateRule = {};\n    dateRule[field] = handleRuleFieldValue(field, values[i]);\n    result.push(dateRule);\n  }\n\n  return result;\n}\n\nfunction handleRuleFieldValue(field, value) {\n  var result = parseInt(value);\n\n  if (\"bymonth\" === field) {\n    result -= 1;\n  }\n\n  if (\"byday\" === field) {\n    result = days[value];\n  }\n\n  return result;\n}\n\nfunction extendObjectArray(firstArray, secondArray) {\n  var result = [];\n\n  for (var i = 0, firstArrayLength = firstArray.length; i < firstArrayLength; i++) {\n    for (var j = 0, secondArrayLength = secondArray.length; j < secondArrayLength; j++) {\n      result.push(extend({}, firstArray[i], secondArray[j]));\n    }\n  }\n\n  return result;\n}\n\nfunction getDatesByRules(dateRules, startDate, rule) {\n  var result = [];\n\n  for (var i = 0, len = dateRules.length; i < len; i++) {\n    var current = dateRules[i];\n    var updatedDate = prepareDate(startDate, dateRules, rule.wkst);\n\n    for (var field in current) {\n      dateSetterMap[field] && dateSetterMap[field](updatedDate, current[field], rule.wkst, rule.freq, rule.fdow);\n    }\n\n    if (Array.isArray(updatedDate)) {\n      result = result.concat(updatedDate);\n    } else {\n      var date = !isWrongDate(updatedDate) ? new Date(updatedDate) : updatedDate;\n      result.push(date);\n    }\n  }\n\n  if (!result.length) {\n    result.push(startDate);\n  }\n\n  return result;\n}\n\nfunction getDatesByCount(dateRules, startDate, recurrenceStartDate, rule) {\n  var result = [];\n  var count = rule.count;\n  var counter = 0;\n  var date = prepareDate(startDate, dateRules, rule.wkst);\n\n  var _loop = function _loop() {\n    var dates = getDatesByRules(dateRules, date, rule);\n    var checkedDates = [];\n    dates.forEach(function (checkedDate) {\n      if (!isWrongDate(checkedDate)) {\n        if (checkedDate.getTime() >= recurrenceStartDate.getTime()) {\n          checkedDates.push(checkedDate);\n        }\n      }\n    });\n    var length = checkedDates.length;\n    counter += length;\n    var delCount = counter - count;\n\n    if (counter > count) {\n      checkedDates.splice(length - delCount, delCount);\n    }\n\n    checkedDates.forEach(function (checkedDate) {\n      return result.push(checkedDate);\n    });\n    var interval = rule.interval;\n\n    if (\"days\" === Object.keys(interval)[0]) {\n      interval = {\n        weeks: 1\n      };\n    }\n\n    date = dateUtils.addInterval(date, interval);\n  };\n\n  while (counter < count) {\n    _loop();\n  }\n\n  return result;\n}\n\nfunction prepareDate(startDate, dateRules, weekStartRule) {\n  var date = new Date(startDate);\n  var day = date.getDay();\n\n  if (dateRules.length && isDefined(dateRules[0].byday)) {\n    date.setDate(date.getDate() - day + days[weekStartRule] - (day < days[weekStartRule] ? 7 : 0));\n  } else {\n    date.setDate(1);\n  }\n\n  return date;\n}\n\nfunction checkDateByRule(date, rules, weekStart) {\n  var result = false;\n\n  for (var i = 0; i < rules.length; i++) {\n    var current = rules[i];\n    var currentRuleResult = true;\n\n    for (var field in current) {\n      var processNegative = \"bymonthday\" === field && current[field] < 0;\n\n      if (dateGetterMap[field] && !processNegative && current[field] !== dateGetterMap[field](date, weekStart)) {\n        currentRuleResult = false;\n      }\n    }\n\n    result = result || currentRuleResult;\n  }\n\n  return result || !rules.length;\n}\n\nfunction markWrongDate(date) {\n  date.isWrongDate = true;\n}\n\nfunction isWrongDate(date) {\n  return date.isWrongDate;\n}\n\nvar getRecurrenceString = function getRecurrenceString(object) {\n  if (!object || !object.freq) {\n    return;\n  }\n\n  var result = \"\";\n\n  for (var field in object) {\n    var value = object[field];\n\n    if (\"interval\" === field && value < 2) {\n      continue;\n    }\n\n    if (\"until\" === field) {\n      value = getAsciiStringByDate(value);\n    }\n\n    result += field + \"=\" + value + \";\";\n  }\n\n  result = result.substring(0, result.length - 1);\n  return result.toUpperCase();\n};\n\nextend(resultUtils, {\n  getRecurrenceString: getRecurrenceString,\n  getRecurrenceRule: getRecurrenceRule,\n  getAsciiStringByDate: getAsciiStringByDate,\n  getDatesByRecurrence: getDatesByRecurrence,\n  dateInRecurrenceRange: dateInRecurrenceRange,\n  getDateByAsciiString: getDateByAsciiString,\n  daysFromByDayRule: daysFromByDayRule,\n  getTimeZoneOffset: getTimeZoneOffset\n});\nmodule.exports = resultUtils;","map":null,"metadata":{},"sourceType":"script"}