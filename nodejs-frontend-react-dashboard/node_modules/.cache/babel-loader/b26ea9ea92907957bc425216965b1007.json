{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.agenda.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _iterator = require(\"../../../core/utils/iterator\");\n\nvar _array = require(\"../../../core/utils/array\");\n\nvar _array2 = _interopRequireDefault(_array);\n\nvar _uiSchedulerAppointmentsStrategy = require(\"./ui.scheduler.appointments.strategy.base\");\n\nvar _uiSchedulerAppointmentsStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsStrategy);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    _setPrototypeOf(subClass, superClass);\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var result,\n        Super = _getPrototypeOf(Derived);\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (\"object\" === _typeof(call) || \"function\" === typeof call)) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (\"undefined\" === typeof Reflect || !Reflect.construct) {\n    return false;\n  }\n\n  if (Reflect.construct.sham) {\n    return false;\n  }\n\n  if (\"function\" === typeof Proxy) {\n    return true;\n  }\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar AgendaRenderingStrategy = function (_BaseAppointmentsStra) {\n  _inherits(AgendaRenderingStrategy, _BaseAppointmentsStra);\n\n  var _super = _createSuper(AgendaRenderingStrategy);\n\n  function AgendaRenderingStrategy() {\n    _classCallCheck(this, AgendaRenderingStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AgendaRenderingStrategy, [{\n    key: \"getAppointmentMinSize\",\n    value: function value() {}\n  }, {\n    key: \"getDeltaTime\",\n    value: function value() {}\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function value(appointments) {\n      var height;\n      var appointmentsByResources;\n\n      if (appointments.length) {\n        height = this.instance.fire(\"getAgendaVerticalStepHeight\");\n        appointmentsByResources = this.instance.fire(\"groupAppointmentsByResources\", appointments);\n        var groupedAppts = [];\n        (0, _iterator.each)(appointmentsByResources, function (i, appts) {\n          var additionalAppointments = [];\n          var recurrentIndexes = [];\n          (0, _iterator.each)(appts, function (index, appointment) {\n            var recurrenceBatch = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index);\n\n            var appointmentBatch = null;\n\n            if (!recurrenceBatch.indexes.length) {\n              appointmentBatch = {\n                parts: []\n              };\n              appointmentBatch = this.instance.getAppointmentsInstance()._processLongAppointment(appointment);\n              additionalAppointments = additionalAppointments.concat(appointmentBatch.parts);\n            }\n\n            additionalAppointments = additionalAppointments.concat(recurrenceBatch.parts);\n            recurrentIndexes = recurrentIndexes.concat(recurrenceBatch.indexes);\n          }.bind(this));\n\n          this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(recurrentIndexes, appts);\n\n          this.instance.getAppointmentsInstance()._combineAppointments(appts, additionalAppointments);\n\n          groupedAppts = groupedAppts.concat(appts);\n        }.bind(this));\n        Array.prototype.splice.apply(appointments, [0, appointments.length].concat(groupedAppts));\n      }\n\n      var result = [];\n      var sortedIndex = 0;\n      appointments.forEach(function (appt, index) {\n        result.push([{\n          height: height,\n          width: \"100%\",\n          sortedIndex: sortedIndex++,\n          groupIndex: this._calculateGroupIndex(index, appointmentsByResources)\n        }]);\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"_calculateGroupIndex\",\n    value: function value(apptIndex, appointmentsByResources) {\n      var resultInd;\n      var counter = 0;\n\n      for (var i in appointmentsByResources) {\n        var countApptInGroup = appointmentsByResources[i].length;\n\n        if (apptIndex >= counter && apptIndex < counter + countApptInGroup) {\n          resultInd = Number(i);\n          break;\n        }\n\n        counter += countApptInGroup;\n      }\n\n      return resultInd;\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function value() {}\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth();\n    }\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_isRtl\",\n    value: function value() {\n      return this.instance.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value() {}\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function value() {}\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function value() {}\n  }, {\n    key: \"isAllDay\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value() {}\n  }, {\n    key: \"_rowCondition\",\n    value: function value() {}\n  }, {\n    key: \"_columnCondition\",\n    value: function value() {}\n  }, {\n    key: \"_findIndexByKey\",\n    value: function value() {}\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function value() {}\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function value() {}\n  }, {\n    key: \"getDefaultCellWidth\",\n    value: function value() {\n      return this._defaultWidth;\n    }\n  }, {\n    key: \"getCollectorLeftOffset\",\n    value: function value() {}\n  }, {\n    key: \"getCollectorTopOffset\",\n    value: function value() {}\n  }, {\n    key: \"calculateRows\",\n    value: function value(appointments, agendaDuration, currentDate, needClearSettings) {\n      this._rows = [];\n      var groupedAppointments = this.instance.fire(\"groupAppointmentsByResources\", appointments);\n      currentDate = _date2.default.trimTime(new Date(currentDate));\n      (0, _iterator.each)(groupedAppointments, function (groupIndex, currentAppointments) {\n        var groupResult = [];\n        var appts = {\n          indexes: [],\n          parts: []\n        };\n\n        if (!currentAppointments.length) {\n          this._rows.push([]);\n\n          return true;\n        }\n\n        (0, _iterator.each)(currentAppointments, function (index, appointment) {\n          var startDate = this.instance.fire(\"getField\", \"startDate\", appointment);\n          var endDate = this.instance.fire(\"getField\", \"endDate\", appointment);\n          this.instance.fire(\"fixWrongEndDate\", appointment, startDate, endDate);\n          needClearSettings && delete appointment.settings;\n\n          var result = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index, false);\n\n          appts.parts = appts.parts.concat(result.parts);\n          appts.indexes = appts.indexes.concat(result.indexes);\n        }.bind(this));\n\n        this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(appts.indexes, currentAppointments);\n\n        _array2.default.merge(currentAppointments, appts.parts);\n\n        var appointmentCount = currentAppointments.length;\n\n        for (var i = 0; i < agendaDuration; i++) {\n          var day = new Date(currentDate);\n          day.setMilliseconds(day.getMilliseconds() + 864e5 * i);\n\n          if (void 0 === groupResult[i]) {\n            groupResult[i] = 0;\n          }\n\n          for (var j = 0; j < appointmentCount; j++) {\n            var appointmentData = currentAppointments[j].settings || currentAppointments[j];\n            var appointmentIsLong = this.instance.fire(\"appointmentTakesSeveralDays\", currentAppointments[j]);\n            var appointmentIsRecurrence = this.instance.fire(\"getField\", \"recurrenceRule\", currentAppointments[j]);\n\n            if (this.instance.fire(\"dayHasAppointment\", day, appointmentData, true) || !appointmentIsRecurrence && appointmentIsLong && this.instance.fire(\"dayHasAppointment\", day, currentAppointments[j], true)) {\n              groupResult[i] += 1;\n            }\n          }\n        }\n\n        this._rows.push(groupResult);\n      }.bind(this));\n      return this._rows;\n    }\n  }, {\n    key: \"_iterateRow\",\n    value: function value(row, obj, index) {\n      for (var i = 0; i < row.length; i++) {\n        obj.counter = obj.counter + row[i];\n\n        if (obj.counter >= index) {\n          obj.indexInRow = i;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"getDateByIndex\",\n    value: function value(index, rows, startViewDate) {\n      var obj = {\n        counter: 0,\n        indexInRow: 0\n      };\n      index++;\n\n      for (var i = 0; i < rows.length; i++) {\n        this._iterateRow(rows[i], obj, index);\n\n        if (obj.indexInRow) {\n          break;\n        }\n      }\n\n      return new Date(new Date(startViewDate).setDate(startViewDate.getDate() + obj.indexInRow));\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function value() {\n      return function ($appointment, originalStartDate) {\n        var apptIndex = $appointment.index();\n        var startViewDate = this.instance.getStartViewDate();\n        var calculatedStartDate = this.getDateByIndex(apptIndex, this._rows, startViewDate);\n        var wrappedOriginalStartDate = new Date(originalStartDate);\n        return {\n          startDate: new Date(calculatedStartDate.setHours(wrappedOriginalStartDate.getHours(), wrappedOriginalStartDate.getMinutes(), wrappedOriginalStartDate.getSeconds(), wrappedOriginalStartDate.getMilliseconds()))\n        };\n      }.bind(this);\n    }\n  }]);\n\n  return AgendaRenderingStrategy;\n}(_uiSchedulerAppointmentsStrategy2.default);\n\nmodule.exports = AgendaRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}