{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.work_space.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar $ = require(\"../../../core/renderer\");\n\nvar domAdapter = require(\"../../../core/dom_adapter\");\n\nvar eventsEngine = require(\"../../../events/core/events_engine\");\n\nvar dataUtils = require(\"../../../core/element_data\");\n\nvar dateUtils = require(\"../../../core/utils/date\");\n\nvar typeUtils = require(\"../../../core/utils/type\");\n\nvar windowUtils = require(\"../../../core/utils/window\");\n\nvar getPublicElement = require(\"../../../core/utils/dom\").getPublicElement;\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar each = require(\"../../../core/utils/iterator\").each;\n\nvar getBoundingRect = require(\"../../../core/utils/position\").getBoundingRect;\n\nvar messageLocalization = require(\"../../../localization/message\");\n\nvar dateLocalization = require(\"../../../localization/date\");\n\nvar toMs = dateUtils.dateToMilliseconds;\n\nvar Widget = require(\"../../widget/ui.widget\");\n\nvar abstract = Widget.abstract;\n\nvar noop = require(\"../../../core/utils/common\").noop;\n\nvar isDefined = require(\"../../../core/utils/type\").isDefined;\n\nvar publisherMixin = require(\"../ui.scheduler.publisher_mixin\");\n\nvar eventUtils = require(\"../../../events/utils\");\n\nvar pointerEvents = require(\"../../../events/pointer\");\n\nvar errors = require(\"../../widget/ui.errors\");\n\nvar clickEvent = require(\"../../../events/click\");\n\nvar contextMenuEvent = require(\"../../../events/contextmenu\");\n\nvar dragEvents = require(\"../../../events/drag\");\n\nvar Scrollable = require(\"../../scroll_view/ui.scrollable\");\n\nvar HorizontalGroupedStrategy = require(\"./ui.scheduler.work_space.grouped.strategy.horizontal\");\n\nvar VerticalGroupedStrategy = require(\"./ui.scheduler.work_space.grouped.strategy.vertical\");\n\nvar tableCreator = require(\"../ui.scheduler.table_creator\");\n\nvar VerticalShader = require(\"../shaders/ui.scheduler.current_time_shader.vertical\");\n\nvar AppointmentDragBehavior = require(\"../appointmentDragBehavior\");\n\nvar FIXED_CONTAINER_CLASS = require(\"../constants\").FIXED_CONTAINER_CLASS;\n\nvar timeZoneUtils = require(\"../utils.timeZone\");\n\nvar COMPONENT_CLASS = \"dx-scheduler-work-space\";\nvar GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-grouped\";\nvar VERTICAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-vertical-grouped\";\nvar WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = \"dx-scheduler-work-space-vertical-group-table\";\nvar WORKSPACE_WITH_BOTH_SCROLLS_CLASS = \"dx-scheduler-work-space-both-scrollbar\";\nvar WORKSPACE_WITH_COUNT_CLASS = \"dx-scheduler-work-space-count\";\nvar WORKSPACE_WITH_GROUP_BY_DATE_CLASS = \"dx-scheduler-work-space-group-by-date\";\nvar WORKSPACE_WITH_ODD_CELLS_CLASS = \"dx-scheduler-work-space-odd-cells\";\nvar TIME_PANEL_CLASS = \"dx-scheduler-time-panel\";\nvar TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\";\nvar TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\";\nvar ALL_DAY_PANEL_CLASS = \"dx-scheduler-all-day-panel\";\nvar ALL_DAY_TABLE_CLASS = \"dx-scheduler-all-day-table\";\nvar ALL_DAY_CONTAINER_CLASS = \"dx-scheduler-all-day-appointments\";\nvar ALL_DAY_TITLE_CLASS = \"dx-scheduler-all-day-title\";\nvar ALL_DAY_TITLE_HIDDEN_CLASS = \"dx-scheduler-all-day-title-hidden\";\nvar ALL_DAY_TABLE_CELL_CLASS = \"dx-scheduler-all-day-table-cell\";\nvar ALL_DAY_TABLE_ROW_CLASS = \"dx-scheduler-all-day-table-row\";\nvar WORKSPACE_WITH_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day\";\nvar WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day-collapsed\";\nvar WORKSPACE_WITH_MOUSE_SELECTION_CLASS = \"dx-scheduler-work-space-mouse-selection\";\nvar HORIZONTAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-horizontal\";\nvar VERTICAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-vertical\";\nvar HEADER_PANEL_CLASS = \"dx-scheduler-header-panel\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar GROUP_ROW_CLASS = \"dx-scheduler-group-row\";\nvar GROUP_HEADER_CLASS = \"dx-scheduler-group-header\";\nvar GROUP_HEADER_CONTENT_CLASS = \"dx-scheduler-group-header-content\";\nvar DATE_TABLE_CLASS = \"dx-scheduler-date-table\";\nvar DATE_TABLE_CELL_CLASS = \"dx-scheduler-date-table-cell\";\nvar DATE_TABLE_ROW_CLASS = \"dx-scheduler-date-table-row\";\nvar DATE_TABLE_FOCUSED_CELL_CLASS = \"dx-scheduler-focused-cell\";\nvar DATE_TABLE_DROPPABLE_CELL_CLASS = \"dx-scheduler-date-table-droppable-cell\";\nvar SCHEDULER_HEADER_SCROLLABLE_CLASS = \"dx-scheduler-header-scrollable\";\nvar SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = \"dx-scheduler-sidebar-scrollable\";\nvar SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = \"dx-scheduler-date-table-scrollable\";\nvar SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, \"dxSchedulerWorkSpace\");\nvar SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME = eventUtils.addNamespace(dragEvents.enter, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXDROP_EVENT_NAME = eventUtils.addNamespace(dragEvents.drop, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXDRAGLEAVE_EVENT_NAME = eventUtils.addNamespace(dragEvents.leave, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXCLICK_EVENT_NAME = eventUtils.addNamespace(clickEvent.name, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = eventUtils.addNamespace(pointerEvents.up, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = eventUtils.addNamespace(pointerEvents.move, \"dxSchedulerDateTable\");\nvar CELL_DATA = \"dxCellData\";\nvar DATE_TABLE_CELL_BORDER = 1;\nvar DATE_TABLE_MIN_CELL_WIDTH = 75;\nvar DAY_MS = toMs(\"day\");\nvar HOUR_MS = toMs(\"hour\");\nvar SCHEDULER_DRAG_AND_DROP_SELECTOR = \".\".concat(DATE_TABLE_CLASS, \" td, .\").concat(ALL_DAY_TABLE_CLASS, \" td\");\n\nvar ScrollSemaphore = function () {\n  function ScrollSemaphore() {\n    _classCallCheck(this, ScrollSemaphore);\n\n    this.counter = 0;\n  }\n\n  _createClass(ScrollSemaphore, [{\n    key: \"isFree\",\n    value: function value() {\n      return 0 === this.counter;\n    }\n  }, {\n    key: \"take\",\n    value: function value() {\n      this.counter++;\n    }\n  }, {\n    key: \"release\",\n    value: function value() {\n      this.counter--;\n\n      if (this.counter < 0) {\n        this.counter = 0;\n      }\n    }\n  }]);\n\n  return ScrollSemaphore;\n}();\n\nvar formatWeekday = function formatWeekday(date) {\n  return dateLocalization.getDayNames(\"abbreviated\")[date.getDay()];\n};\n\nvar SchedulerWorkSpace = Widget.inherit({\n  _supportedKeys: function _supportedKeys() {\n    var clickHandler = function clickHandler(e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (this._focusedCells && this._focusedCells.length) {\n        var $itemElement = $(this.option(\"focusedElement\"));\n        var $cellElement = $itemElement.length ? $itemElement : this._focusedCells;\n        e.target = this._focusedCells;\n        this._showPopup = true;\n\n        this._cellClickAction({\n          event: e,\n          cellElement: $(this._focusedCells),\n          cellData: this.getCellData($cellElement)\n        });\n      }\n    };\n\n    var arrowPressHandler = function arrowPressHandler(e, cell) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      this._moveToCell(cell, e.shiftKey);\n    };\n\n    return extend(this.callBase(), {\n      enter: clickHandler,\n      space: clickHandler,\n      downArrow: function downArrow(e) {\n        var $cell = this._getCellFromNextRow(\"next\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $cell);\n      },\n      upArrow: function upArrow(e) {\n        var $cell = this._getCellFromNextRow(\"prev\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $cell);\n      },\n      rightArrow: function rightArrow(e) {\n        var $rightCell = this._getCellFromNextColumn(\"next\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $rightCell);\n      },\n      leftArrow: function leftArrow(e) {\n        var $leftCell = this._getCellFromNextColumn(\"prev\", e.shiftKey);\n\n        arrowPressHandler.call(this, e, $leftCell);\n      }\n    });\n  },\n  _isRTL: function _isRTL() {\n    return this.option(\"rtlEnabled\");\n  },\n  _getFocusedCell: function _getFocusedCell() {\n    return this._$focusedCell || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n  },\n  _getAllFocusedCells: function _getAllFocusedCells() {\n    return this._focusedCells || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n  },\n  _getCellFromNextRow: function _getCellFromNextRow(direction) {\n    var $currentCell = this._$focusedCell;\n\n    if (isDefined($currentCell)) {\n      var cellIndex = $currentCell.index();\n      var $row = $currentCell.parent();\n      var $cell = $row[direction]().children().eq(cellIndex);\n      $cell = this._checkForViewBounds($cell);\n      return $cell;\n    }\n  },\n  _checkForViewBounds: function _checkForViewBounds($item) {\n    if (!$item.length) {\n      $item = this._$focusedCell;\n    }\n\n    return $item;\n  },\n  _getCellFromNextColumn: function _getCellFromNextColumn(direction, isMultiSelection) {\n    var $focusedCell = this._$focusedCell;\n\n    if (!isDefined($focusedCell)) {\n      return;\n    }\n\n    var $nextCell;\n    var $row = $focusedCell.parent();\n    var nextColumnDirection = direction;\n    var isDirectionNext = \"next\" === direction;\n    var previousColumnDirection = isDirectionNext ? \"prev\" : \"next\";\n\n    var isRTL = this._isRTL();\n\n    var groupCount = this._getGroupCount();\n\n    var isHorizontalGrouping = this._isHorizontalGroupedWorkSpace();\n\n    var isGroupedByDate = this.isGroupedByDate();\n\n    var totalCellCount = this._getTotalCellCount(groupCount);\n\n    var rowCellCount = isMultiSelection && !isGroupedByDate ? this._getCellCount() : totalCellCount;\n    var lastIndexInRow = rowCellCount - 1;\n    var currentIndex = $focusedCell.index();\n    var step = isGroupedByDate && isMultiSelection ? groupCount : 1;\n\n    var isEdgeCell = this._isEdgeCell(isHorizontalGrouping ? totalCellCount - 1 : lastIndexInRow, currentIndex, step, direction);\n\n    var sign = isRTL ? 1 : -1;\n    var directionSign = isDirectionNext ? 1 : -1;\n    var resultingSign = sign * directionSign;\n\n    if (isEdgeCell || isMultiSelection && this._isGroupEndCell($focusedCell, direction)) {\n      var nextIndex = currentIndex - resultingSign * step + resultingSign * rowCellCount;\n      var rowDirection = isRTL ? previousColumnDirection : nextColumnDirection;\n      $nextCell = $row[rowDirection]().children().eq(nextIndex);\n      $nextCell = this._checkForViewBounds($nextCell);\n    } else {\n      $nextCell = $row.children().eq(currentIndex - resultingSign * step);\n    }\n\n    return $nextCell;\n  },\n  _isEdgeCell: function _isEdgeCell(lastIndexInRow, cellIndex, step, direction) {\n    var isRTL = this._isRTL();\n\n    var isDirectionNext = \"next\" === direction;\n    var rightEdgeCellIndex = isRTL ? 0 : lastIndexInRow;\n    var leftEdgeCellIndex = isRTL ? lastIndexInRow : 0;\n    var edgeCellIndex = isDirectionNext ? rightEdgeCellIndex : leftEdgeCellIndex;\n    var isNextCellGreaterThanEdge = cellIndex + step > edgeCellIndex;\n    var isNextCellLessThanEdge = cellIndex - step < edgeCellIndex;\n    var isRightEdgeCell = isRTL ? isNextCellLessThanEdge : isNextCellGreaterThanEdge;\n    var isLeftEdgeCell = isRTL ? isNextCellGreaterThanEdge : isNextCellLessThanEdge;\n    return isDirectionNext ? isRightEdgeCell : isLeftEdgeCell;\n  },\n  _isGroupEndCell: function _isGroupEndCell($cell, direction) {\n    if (this.isGroupedByDate()) {\n      return false;\n    }\n\n    var isDirectionNext = \"next\" === direction;\n\n    var cellsInRow = this._getCellCount();\n\n    var currentCellIndex = $cell.index();\n    var result = currentCellIndex % cellsInRow;\n    var endCell = isDirectionNext ? cellsInRow - 1 : 0;\n    var startCell = isDirectionNext ? 0 : cellsInRow - 1;\n    return this._isRTL() ? result === startCell : result === endCell;\n  },\n  _moveToCell: function _moveToCell($cell, isMultiSelection) {\n    isMultiSelection = isMultiSelection && this.option(\"allowMultipleCellSelection\");\n\n    this._setFocusedCell($cell, isMultiSelection);\n\n    this._dateTableScrollable.scrollToElement($cell);\n  },\n  _setFocusedCell: function _setFocusedCell($cell, isMultiSelection) {\n    if (!isDefined($cell) || !$cell.length) {\n      return;\n    }\n\n    this._releaseFocusedCell();\n\n    this._focusedCells = [];\n\n    if (isMultiSelection) {\n      $cell = this._correctCellForGroup($cell);\n      var orientation = \"day\" === this.option(\"type\") && (!this.option(\"groups\").length || \"vertical\" === this.option(\"groupOrientation\")) ? \"vertical\" : \"horizontal\";\n\n      var $targetCells = this._getCellsBetween($cell, this._$prevCell, orientation);\n\n      this._focusedCells = $targetCells.toArray();\n    } else {\n      this._focusedCells = [$cell.get(0)];\n      this._$prevCell = $cell;\n    }\n\n    var $focusedCells = $(this._focusedCells);\n\n    this._toggleFocusClass(true, $focusedCells);\n\n    this.setAria(\"label\", \"Add appointment\", $focusedCells);\n\n    this._toggleFocusedCellClass(true, $cell);\n\n    this._$focusedCell = $cell;\n    var selectedCellData = this.getFocusedCellData();\n    this.option(\"selectedCellData\", selectedCellData);\n\n    this._selectionChangedAction({\n      selectedCellData: selectedCellData\n    });\n  },\n  _correctCellForGroup: function _correctCellForGroup($cell) {\n    var $focusedCell = this._$focusedCell;\n\n    var cellGroupIndex = this._getGroupIndexByCell($cell);\n\n    var focusedCellGroupIndex = this._getGroupIndexByCell($focusedCell);\n\n    var isDifferentTables = this._hasAllDayClass($cell) !== this._hasAllDayClass($focusedCell);\n\n    return focusedCellGroupIndex !== cellGroupIndex || isDifferentTables ? $focusedCell : $cell;\n  },\n  _getCellsBetween: function _getCellsBetween($first, $last, direction) {\n    var isAllDayTable = this._hasAllDayClass($last);\n\n    var $cells = this._getCells(isAllDayTable, direction);\n\n    var firstIndex = $cells.index($first);\n    var lastIndex = $cells.index($last);\n\n    if (firstIndex > lastIndex) {\n      var buffer = firstIndex;\n      firstIndex = lastIndex;\n      lastIndex = buffer;\n    }\n\n    $cells = $cells.slice(firstIndex, lastIndex + 1);\n\n    if (this._getGroupCount() > 1) {\n      var result = [];\n\n      var focusedGroupIndex = this._getGroupIndexByCell($first);\n\n      each($cells, function (_, cell) {\n        var groupIndex = this._getGroupIndexByCell($(cell));\n\n        if (focusedGroupIndex === groupIndex) {\n          result.push(cell);\n        }\n      }.bind(this));\n      $cells = $(result);\n    }\n\n    return $cells;\n  },\n  _hasAllDayClass: function _hasAllDayClass($cell) {\n    return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n  },\n  _getGroupIndexByCell: function _getGroupIndexByCell($cell) {\n    return this._groupedStrategy.getGroupIndexByCell($cell);\n  },\n  _toggleFocusedCellClass: function _toggleFocusedCellClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(DATE_TABLE_FOCUSED_CELL_CLASS, isFocused);\n  },\n  _releaseFocusedCell: function _releaseFocusedCell($cell) {\n    $cell = $cell || $(this._focusedCells);\n\n    if (isDefined($cell) && $cell.length) {\n      this._toggleFocusClass(false, $cell);\n\n      this._toggleFocusedCellClass(false, $cell);\n\n      this.setAria(\"label\", void 0, $cell);\n    }\n\n    this.option(\"selectedCellData\", []);\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    if ($(e.target).is(this._focusTarget()) && false !== this._isCellClick) {\n      delete this._isCellClick;\n      delete this._contextMenuHandled;\n      this.callBase.apply(this, arguments);\n\n      var $cell = this._getFocusedCell();\n\n      this._setFocusedCell($cell);\n    }\n  },\n  _focusOutHandler: function _focusOutHandler() {\n    this.callBase.apply(this, arguments);\n\n    if (!this._contextMenuHandled) {\n      this._releaseFocusedCell();\n    }\n  },\n  _focusTarget: function _focusTarget() {\n    return this.$element();\n  },\n  _activeStateUnit: \".\" + DATE_TABLE_CELL_CLASS + \", .\" + ALL_DAY_TABLE_CELL_CLASS,\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      currentDate: new Date(),\n      intervalCount: 1,\n      startDate: null,\n      firstDayOfWeek: void 0,\n      startDayHour: 0,\n      endDayHour: 24,\n      hoursInterval: .5,\n      activeStateEnabled: true,\n      hoverStateEnabled: true,\n      groups: [],\n      showAllDayPanel: true,\n      allDayExpanded: false,\n      onCellClick: null,\n      crossScrollingEnabled: false,\n      dataCellTemplate: null,\n      timeCellTemplate: null,\n      resourceCellTemplate: null,\n      dateCellTemplate: null,\n      allowMultipleCellSelection: true,\n      indicatorTime: new Date(),\n      indicatorUpdateInterval: 5 * toMs(\"minute\"),\n      shadeUntilCurrentTime: true,\n      groupOrientation: \"horizontal\",\n      selectedCellData: [],\n      groupByDate: false\n    });\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"startDayHour\":\n      case \"endDayHour\":\n        this.invoke(\"validateDayHours\");\n\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"dateCellTemplate\":\n      case \"resourceCellTemplate\":\n      case \"dataCellTemplate\":\n      case \"timeCellTemplate\":\n      case \"hoursInterval\":\n      case \"firstDayOfWeek\":\n      case \"currentDate\":\n      case \"startDate\":\n        this._cleanWorkSpace();\n\n        break;\n\n      case \"groups\":\n        this._cleanView();\n\n        this._removeAllDayElements();\n\n        this._initGrouping();\n\n        this.repaint();\n        break;\n\n      case \"groupOrientation\":\n        this._initGroupedStrategy();\n\n        this._createAllDayPanelElements();\n\n        this._removeAllDayElements();\n\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"showAllDayPanel\":\n        if (this._isVerticalGroupedWorkSpace()) {\n          this._cleanView();\n\n          this._removeAllDayElements();\n\n          this._initGrouping();\n\n          this.repaint();\n        } else {\n          this._toggleAllDayVisibility();\n        }\n\n        break;\n\n      case \"allDayExpanded\":\n        this._changeAllDayVisibility();\n\n        this._attachTablesEvents();\n\n        this.headerPanelOffsetRecalculate();\n\n        this._updateScrollable();\n\n        break;\n\n      case \"onSelectionChanged\":\n        this._createSelectionChangedAction();\n\n        break;\n\n      case \"onCellClick\":\n        this._createCellClickAction();\n\n        break;\n\n      case \"onCellContextMenu\":\n        this._attachContextMenuEvent();\n\n        break;\n\n      case \"intervalCount\":\n        this._cleanWorkSpace();\n\n        this._toggleWorkSpaceCountClass();\n\n        this._toggleFixedScrollableClass();\n\n        break;\n\n      case \"groupByDate\":\n        this._cleanWorkSpace();\n\n        this._toggleGroupByDateClass();\n\n        break;\n\n      case \"crossScrollingEnabled\":\n        this._toggleHorizontalScrollClass();\n\n        this._dateTableScrollable.option(this._dateTableScrollableConfig());\n\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"allowMultipleCellSelection\":\n        break;\n\n      case \"selectedCellData\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _cleanWorkSpace: function _cleanWorkSpace() {\n    this._cleanView();\n\n    this._toggleGroupedClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this._renderView();\n  },\n  _init: function _init() {\n    this._headerSemaphore = new ScrollSemaphore();\n    this._sideBarSemaphore = new ScrollSemaphore();\n    this._dataTableSemaphore = new ScrollSemaphore();\n    this.callBase();\n\n    this._initGrouping();\n\n    this._toggleHorizontalScrollClass();\n\n    this._toggleWorkSpaceCountClass();\n\n    this._toggleGroupByDateClass();\n\n    this._toggleWorkSpaceWithOddCells();\n\n    this.$element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());\n  },\n  _initGrouping: function _initGrouping() {\n    this._initGroupedStrategy();\n\n    this._toggleGroupingDirectionClass();\n\n    this._toggleGroupByDateClass();\n  },\n  _initGroupedStrategy: function _initGroupedStrategy() {\n    var strategyName = this.option(\"groups\").length ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n    var Strategy = \"vertical\" === strategyName ? VerticalGroupedStrategy : HorizontalGroupedStrategy;\n    this._groupedStrategy = new Strategy(this);\n  },\n  _getDefaultGroupStrategy: function _getDefaultGroupStrategy() {\n    return \"horizontal\";\n  },\n  _isVerticalGroupedWorkSpace: function _isVerticalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"vertical\" === this.option(\"groupOrientation\");\n  },\n  _isHorizontalGroupedWorkSpace: function _isHorizontalGroupedWorkSpace() {\n    return !!this.option(\"groups\").length && \"horizontal\" === this.option(\"groupOrientation\");\n  },\n  _toggleHorizontalScrollClass: function _toggleHorizontalScrollClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option(\"crossScrollingEnabled\"));\n  },\n  _toggleGroupByDateClass: function _toggleGroupByDateClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());\n  },\n  _toggleWorkSpaceCountClass: function _toggleWorkSpaceCountClass() {\n    this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());\n  },\n  _isWorkSpaceWithCount: function _isWorkSpaceWithCount() {\n    return this.option(\"intervalCount\") > 1;\n  },\n  _toggleWorkSpaceWithOddCells: function _toggleWorkSpaceWithOddCells() {\n    this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());\n  },\n  _isWorkspaceWithOddCells: function _isWorkspaceWithOddCells() {\n    return .5 === this.option(\"hoursInterval\");\n  },\n  _toggleGroupingDirectionClass: function _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());\n  },\n  _getRealGroupOrientation: function _getRealGroupOrientation() {\n    return this._isVerticalGroupedWorkSpace() ? \"vertical\" : \"horizontal\";\n  },\n  _getTimePanelClass: function _getTimePanelClass() {\n    return TIME_PANEL_CLASS;\n  },\n  _getDateTableClass: function _getDateTableClass() {\n    return DATE_TABLE_CLASS;\n  },\n  _getDateTableRowClass: function _getDateTableRowClass() {\n    return DATE_TABLE_ROW_CLASS;\n  },\n  _getDateTableCellClass: function _getDateTableCellClass(i, j) {\n    var cellClass = DATE_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._needApplyLastGroupCellClass() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1, i, j) : cellClass;\n  },\n  _needApplyLastGroupCellClass: function _needApplyLastGroupCellClass() {\n    return true;\n  },\n  _getGroupRowClass: function _getGroupRowClass() {\n    return GROUP_ROW_CLASS;\n  },\n  _getGroupHeaderClass: function _getGroupHeaderClass(i) {\n    var cellClass = GROUP_HEADER_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n  },\n  _getGroupHeaderContentClass: function _getGroupHeaderContentClass() {\n    return GROUP_HEADER_CONTENT_CLASS;\n  },\n  _initWorkSpaceUnits: function _initWorkSpaceUnits() {\n    this._$headerPanel = $(\"<table>\");\n    this._$thead = $(\"<thead>\").appendTo(this._$headerPanel);\n    this._$fixedContainer = $(\"<div>\").addClass(FIXED_CONTAINER_CLASS);\n    this._$allDayContainer = $(\"<div>\").addClass(ALL_DAY_CONTAINER_CLASS);\n\n    this._initAllDayPanelElements();\n\n    this._createAllDayPanelElements();\n\n    this._$timePanel = $(\"<table>\").addClass(this._getTimePanelClass());\n    this._$dateTable = $(\"<table>\");\n    this._$groupTable = $(\"<div>\").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);\n  },\n  _initAllDayPanelElements: function _initAllDayPanelElements() {\n    this._allDayTitles = [];\n    this._allDayTables = [];\n    this._allDayPanels = [];\n  },\n  _createAllDayPanelElements: function _createAllDayPanelElements() {\n    var groupCount = this._getGroupCount();\n\n    if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {\n      for (var i = 0; i < groupCount; i++) {\n        var $allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\"));\n\n        this._allDayTitles.push($allDayTitle);\n\n        this._$allDayTable = $(\"<table>\");\n\n        this._allDayTables.push(this._$allDayTable);\n\n        this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n\n        this._allDayPanels.push(this._$allDayPanel);\n      }\n    } else {\n      this._$allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\")).appendTo(this.$element());\n      this._$allDayTable = $(\"<table>\");\n      this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n    }\n  },\n  _initDateTableScrollable: function _initDateTableScrollable() {\n    var $dateTableScrollable = $(\"<div>\").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);\n    this._dateTableScrollable = this._createComponent($dateTableScrollable, Scrollable, this._dateTableScrollableConfig());\n  },\n  _dateTableScrollableConfig: function _dateTableScrollableConfig() {\n    var config = {\n      useKeyboard: false,\n      bounceEnabled: false,\n      updateManually: true,\n      pushBackValue: 0\n    };\n\n    if (this._needCreateCrossScrolling()) {\n      config = extend(config, this._createCrossScrollingConfig());\n    }\n\n    return config;\n  },\n  _createCrossScrollingConfig: function _createCrossScrollingConfig() {\n    var _this = this;\n\n    var config = {};\n    config.direction = \"both\";\n\n    config.onScroll = function (e) {\n      _this._dataTableSemaphore.take();\n\n      _this._sideBarSemaphore.isFree() && _this._sidebarScrollable && _this._sidebarScrollable.scrollTo({\n        top: e.scrollOffset.top\n      });\n      _this._headerSemaphore.isFree() && _this._headerScrollable && _this._headerScrollable.scrollTo({\n        left: e.scrollOffset.left\n      });\n\n      _this._dataTableSemaphore.release();\n    };\n\n    config.onEnd = function () {\n      _this.notifyObserver(\"updateResizableArea\", {});\n    };\n\n    return config;\n  },\n  _createWorkSpaceElements: function _createWorkSpaceElements() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._createWorkSpaceScrollableElements();\n    } else {\n      this._createWorkSpaceStaticElements();\n    }\n  },\n  _createWorkSpaceStaticElements: function _createWorkSpaceStaticElements() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._dateTableScrollable.$content().append(this._$allDayContainer, this._$groupTable, this._$timePanel, this._$dateTable);\n\n      this.$element().append(this._$fixedContainer, this._$headerPanel, this._dateTableScrollable.$element());\n    } else {\n      this._dateTableScrollable.$content().append(this._$timePanel, this._$dateTable);\n\n      this.$element().append(this._$fixedContainer, this._$headerPanel, this._$allDayContainer, this._$allDayPanel, this._dateTableScrollable.$element());\n    }\n  },\n  _createWorkSpaceScrollableElements: function _createWorkSpaceScrollableElements() {\n    this.$element().append(this._$fixedContainer);\n\n    this._createHeaderScrollable();\n\n    this._createSidebarScrollable();\n\n    this.$element().append(this._dateTableScrollable.$element());\n\n    this._headerScrollable.$content().append(this._$headerPanel);\n\n    this._dateTableScrollable.$content().append(this._$dateTable);\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._dateTableScrollable.$content().prepend(this._$allDayContainer);\n\n      this._sidebarScrollable.$content().append(this._$groupTable, this._$timePanel);\n    } else {\n      this._headerScrollable.$content().append(this._$allDayContainer, this._$allDayPanel);\n    }\n\n    this._sidebarScrollable.$content().append(this._$timePanel);\n  },\n  _createHeaderScrollable: function _createHeaderScrollable() {\n    var $headerScrollable = $(\"<div>\").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this.$element());\n    this._headerScrollable = this._createComponent($headerScrollable, Scrollable, this._headerScrollableConfig());\n  },\n  _headerScrollableConfig: function _headerScrollableConfig() {\n    var _this2 = this;\n\n    var config = {\n      useKeyboard: false,\n      showScrollbar: false,\n      direction: \"horizontal\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      pushBackValue: 0,\n      onScroll: function onScroll(e) {\n        _this2._headerSemaphore.take();\n\n        _this2._dataTableSemaphore.isFree() && _this2._dateTableScrollable.scrollTo({\n          left: e.scrollOffset.left\n        });\n\n        _this2._headerSemaphore.release();\n      }\n    };\n    return config;\n  },\n  _createSidebarScrollable: function _createSidebarScrollable() {\n    var _this3 = this;\n\n    var $timePanelScrollable = $(\"<div>\").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this.$element());\n    this._sidebarScrollable = this._createComponent($timePanelScrollable, Scrollable, {\n      useKeyboard: false,\n      showScrollbar: false,\n      direction: \"vertical\",\n      useNative: false,\n      updateManually: true,\n      bounceEnabled: false,\n      pushBackValue: 0,\n      onScroll: function onScroll(e) {\n        _this3._sideBarSemaphore.take();\n\n        _this3._dataTableSemaphore.isFree() && _this3._dateTableScrollable.scrollTo({\n          top: e.scrollOffset.top\n        });\n\n        _this3._sideBarSemaphore.release();\n      }\n    });\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible && this._isVerticalGroupedWorkSpace()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n\n    if (visible && this._needCreateCrossScrolling()) {\n      this._setTableSizes();\n    }\n  },\n  _attachTableClasses: function _attachTableClasses() {\n    this._addTableClass(this._$dateTable, this._getDateTableClass());\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);\n      }\n    } else {\n      this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);\n    }\n  },\n  _attachHeaderTableClasses: function _attachHeaderTableClasses() {\n    this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);\n  },\n  _addTableClass: function _addTableClass($el, className) {\n    $el && !$el.hasClass(className) && $el.addClass(className);\n  },\n  _setTableSizes: function _setTableSizes() {\n    this._attachTableClasses();\n\n    var cellWidth = this.getCellWidth();\n\n    if (cellWidth < this.getCellMinWidth()) {\n      cellWidth = this.getCellMinWidth();\n    }\n\n    var minWidth = this.getWorkSpaceMinWidth();\n\n    var $headerCells = this._$headerPanel.find(\"tr\").last().find(\"th\");\n\n    var width = cellWidth * $headerCells.length;\n\n    if (width < minWidth) {\n      width = minWidth;\n    }\n\n    this._$headerPanel.width(width);\n\n    this._$dateTable.width(width);\n\n    this._$allDayTable && this._$allDayTable.width(width);\n\n    this._attachHeaderTableClasses();\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n  },\n  getWorkSpaceMinWidth: function getWorkSpaceMinWidth() {\n    return this._groupedStrategy.getWorkSpaceMinWidth();\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      this._setTableSizes();\n    }\n\n    this.headerPanelOffsetRecalculate();\n\n    this._cleanCellDataCache();\n\n    this._cleanAllowedPositions();\n  },\n  _needCreateCrossScrolling: function _needCreateCrossScrolling() {\n    return this.option(\"crossScrollingEnabled\");\n  },\n  _getElementClass: noop,\n  _getRowCount: noop,\n  _getCellCount: noop,\n  _getRowCountWithAllDayRows: function _getRowCountWithAllDayRows() {\n    var allDayRowCount = this.option(\"showAllDayPanel\") ? 1 : 0;\n    return this._getRowCount() + allDayRowCount;\n  },\n  _initMarkup: function _initMarkup() {\n    this._initWorkSpaceUnits();\n\n    this._initDateTableScrollable();\n\n    this._createWorkSpaceElements();\n\n    this.callBase();\n\n    if (!this.option(\"crossScrollingEnabled\")) {\n      this._attachTableClasses();\n\n      this._attachHeaderTableClasses();\n    }\n\n    this._toggleGroupedClass();\n\n    this._toggleFixedScrollableClass();\n\n    this._renderView();\n\n    this._attachEvents();\n\n    this._setFocusOnCellByOption(this.option(\"selectedCellData\"));\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderDateTimeIndication();\n\n    this._setIndicationUpdateInterval();\n  },\n  _toggleGroupedClass: function _toggleGroupedClass() {\n    this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);\n  },\n  _toggleFixedScrollableClass: noop,\n  _renderView: function _renderView() {\n    this._setFirstViewDate();\n\n    this._applyCellTemplates(this._renderGroupHeader());\n\n    this._renderDateHeader();\n\n    this._renderTimePanel();\n\n    if (this._isVerticalGroupedWorkSpace()) {\n      var groupCount = this._getGroupCount();\n\n      for (var i = 0; i < groupCount; i++) {\n        this._renderAllDayPanel(i);\n      }\n    }\n\n    this._renderDateTable();\n\n    this._renderAllDayPanel();\n\n    this._updateGroupTableHeight();\n\n    this._shader = new VerticalShader(this);\n  },\n  _updateGroupTableHeight: function _updateGroupTableHeight() {\n    if (this._isVerticalGroupedWorkSpace() && windowUtils.hasWindow()) {\n      this._setHorizontalGroupHeaderCellsHeight();\n    }\n  },\n  _renderDateTimeIndication: noop,\n  _setIndicationUpdateInterval: noop,\n  _refreshDateTimeIndication: noop,\n  _setFocusOnCellByOption: function _setFocusOnCellByOption(data) {\n    var cells = [];\n\n    this._releaseFocusedCell();\n\n    for (var i = 0; i < data.length; i++) {\n      var groups = data[i].groups;\n      var groupIndex = this.option(\"groups\").length && groups ? this._getGroupIndexByResourceId(groups) : 0;\n      var allDay = !!data[i].allDay;\n      var coordinates = this.getCoordinatesByDate(data[i].startDate, groupIndex, allDay);\n\n      var $cell = this._getCellByCoordinates(coordinates, groupIndex);\n\n      if (isDefined($cell)) {\n        this._toggleFocusClass(true, $cell);\n\n        cells.push($cell.get(0));\n      }\n    }\n\n    this._focusedCells = cells;\n  },\n  _getGroupIndexByResourceId: function _getGroupIndexByResourceId(id) {\n    var groups = this.option(\"groups\");\n    var resourceTree = this.invoke(\"createResourcesTree\", groups);\n\n    if (!resourceTree.length) {\n      return 0;\n    }\n\n    return this._getGroupIndexRecursively(resourceTree, id);\n  },\n  _getGroupIndexRecursively: function _getGroupIndexRecursively(resourceTree, id) {\n    var _this4 = this;\n\n    var currentKey = resourceTree[0].name;\n    var currentValue = id[currentKey];\n    return resourceTree.reduce(function (prevIndex, _ref) {\n      var leafIndex = _ref.leafIndex,\n          value = _ref.value,\n          children = _ref.children;\n      var areValuesEqual = currentValue === value;\n\n      if (areValuesEqual && void 0 !== leafIndex) {\n        return leafIndex;\n      }\n\n      if (areValuesEqual) {\n        return _this4._getGroupIndexRecursively(children, id);\n      }\n\n      return prevIndex;\n    }, 0);\n  },\n  _setFirstViewDate: function _setFirstViewDate() {\n    var firstDayOfWeek = isDefined(this._firstDayOfWeek()) ? this._firstDayOfWeek() : dateLocalization.firstDayOfWeekIndex();\n    this._firstViewDate = dateUtils.getFirstWeekDate(this._getViewStartByOptions(), firstDayOfWeek);\n\n    this._setStartDayHour(this._firstViewDate);\n  },\n  _getViewStartByOptions: function _getViewStartByOptions() {\n    if (!this.option(\"startDate\")) {\n      return this.option(\"currentDate\");\n    } else {\n      var startDate = dateUtils.trimTime(this._getStartViewDate());\n      var currentDate = this.option(\"currentDate\");\n      var diff = startDate.getTime() <= currentDate.getTime() ? 1 : -1;\n      var endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n\n      while (!this._dateInRange(currentDate, startDate, endDate, diff)) {\n        startDate = endDate;\n        endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n      }\n\n      return diff > 0 ? startDate : endDate;\n    }\n  },\n  _getHeaderDate: function _getHeaderDate() {\n    return this.getStartViewDate();\n  },\n  _getStartViewDate: function _getStartViewDate() {\n    return this.option(\"startDate\");\n  },\n  _dateInRange: function _dateInRange(date, startDate, endDate, diff) {\n    return diff > 0 ? dateUtils.dateInRange(date, startDate, new Date(endDate.getTime() - 1)) : dateUtils.dateInRange(date, endDate, startDate, \"date\");\n  },\n  _getIntervalDuration: function _getIntervalDuration() {\n    return toMs(\"day\") * this.option(\"intervalCount\");\n  },\n  _setStartDayHour: function _setStartDayHour(date) {\n    var startDayHour = this.option(\"startDayHour\");\n\n    if (isDefined(startDayHour)) {\n      date.setHours(startDayHour, startDayHour % 1 * 60, 0, 0);\n    }\n  },\n  _firstDayOfWeek: function _firstDayOfWeek() {\n    return this.option(\"firstDayOfWeek\");\n  },\n  _attachEvents: function _attachEvents() {\n    this._createSelectionChangedAction();\n\n    this._attachClickEvent();\n\n    this._attachContextMenuEvent();\n  },\n  _attachClickEvent: function _attachClickEvent() {\n    var that = this;\n\n    var pointerDownAction = this._createAction(function (e) {\n      that._pointerDownHandler(e.event);\n    });\n\n    this._createCellClickAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n    var $element = this.$element();\n    eventsEngine.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);\n    eventsEngine.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function (e) {\n      if (eventUtils.isMouseEvent(e) && e.which > 1) {\n        e.preventDefault();\n        return;\n      }\n\n      pointerDownAction({\n        event: e\n      });\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function (e) {\n      var $cell = $(e.target);\n\n      that._cellClickAction({\n        event: e,\n        cellElement: getPublicElement($cell),\n        cellData: that.getCellData($cell)\n      });\n    });\n  },\n  _createCellClickAction: function _createCellClickAction() {\n    var that = this;\n    this._cellClickAction = this._createActionByOption(\"onCellClick\", {\n      afterExecute: function afterExecute(e) {\n        that._moveToClosestNonStub(e.args[0].event);\n      }\n    });\n  },\n  _createSelectionChangedAction: function _createSelectionChangedAction() {\n    this._selectionChangedAction = this._createActionByOption(\"onSelectionChanged\");\n  },\n  _moveToClosestNonStub: function _moveToClosestNonStub(e) {\n    var $target = $(e.target);\n\n    if (this._showPopup && this._hasFocusClass($target)) {\n      delete this._showPopup;\n\n      this._showAddAppointmentPopup($target);\n    }\n  },\n  _pointerDownHandler: function _pointerDownHandler(e) {\n    var $target = $(e.target);\n\n    if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {\n      this._isCellClick = false;\n      return;\n    }\n\n    this._isCellClick = true;\n\n    if ($target.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n      this._showPopup = true;\n    } else {\n      this._setFocusedCell($target);\n    }\n  },\n  _showAddAppointmentPopup: function _showAddAppointmentPopup($cell) {\n    var firstCellData = this.getCellData($cell.first());\n    var lastCellData = this.getCellData($cell.last());\n    var args = {\n      startDate: this.invoke(\"convertDateByTimezoneBack\", firstCellData.startDate) || firstCellData.startDate,\n      endDate: this.invoke(\"convertDateByTimezoneBack\", lastCellData.endDate) || lastCellData.endDate\n    };\n\n    if (isDefined(lastCellData.allDay)) {\n      args.allDay = lastCellData.allDay;\n    }\n\n    extend(args, lastCellData.groups);\n    this.notifyObserver(\"showAddAppointmentPopup\", args);\n  },\n  _attachContextMenuEvent: function _attachContextMenuEvent() {\n    this._createContextMenuAction();\n\n    var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n    var $element = this.$element();\n    var eventName = eventUtils.addNamespace(contextMenuEvent.name, this.NAME);\n    eventsEngine.off($element, eventName, cellSelector);\n    eventsEngine.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));\n  },\n  _contextMenuHandler: function _contextMenuHandler(e) {\n    var $cell = $(e.target);\n\n    this._contextMenuAction({\n      event: e,\n      cellElement: getPublicElement($cell),\n      cellData: this.getCellData($cell)\n    });\n\n    this._contextMenuHandled = true;\n  },\n  _createContextMenuAction: function _createContextMenuAction() {\n    this._contextMenuAction = this._createActionByOption(\"onCellContextMenu\");\n  },\n  _getGroupHeaderContainer: function _getGroupHeaderContainer() {\n    if (this._isVerticalGroupedWorkSpace()) {\n      return this._$groupTable;\n    }\n\n    return this._$thead;\n  },\n  _getDateHeaderContainer: function _getDateHeaderContainer() {\n    return this._$thead;\n  },\n  _renderGroupHeader: function _renderGroupHeader() {\n    var $container = this._getGroupHeaderContainer();\n\n    var groupCount = this._getGroupCount();\n\n    var cellTemplates = [];\n\n    if (groupCount) {\n      var groupRows = this._makeGroupRows(this.option(\"groups\"), this.option(\"groupByDate\"));\n\n      this._attachGroupCountAttr(groupCount, groupRows);\n\n      $container.append(groupRows.elements);\n      cellTemplates = groupRows.cellTemplates;\n    } else {\n      this._detachGroupCountAttr();\n    }\n\n    return cellTemplates;\n  },\n  _applyCellTemplates: function _applyCellTemplates(templates) {\n    templates.forEach(function (template) {\n      template();\n    });\n  },\n  _detachGroupCountAttr: function _detachGroupCountAttr() {\n    var groupedAttr = this._groupedStrategy.getGroupCountAttr();\n\n    this.$element().removeAttr(groupedAttr.attr);\n  },\n  _attachGroupCountAttr: function _attachGroupCountAttr(groupRowCount, groupRows) {\n    var groupedAttr = this._groupedStrategy.getGroupCountAttr(groupRowCount, groupRows);\n\n    this.$element().attr(groupedAttr.attr, groupedAttr.count);\n  },\n  headerPanelOffsetRecalculate: function headerPanelOffsetRecalculate() {\n    if (!this.option(\"resourceCellTemplate\") && !this.option(\"dateCellTemplate\")) {\n      return;\n    }\n\n    var headerPanelHeight = this.getHeaderPanelHeight();\n    var headerHeight = this.invoke(\"getHeaderHeight\");\n    var allDayPanelHeight = this.supportAllDayRow() && this.option(\"showAllDayPanel\") ? this._groupedStrategy.getAllDayTableHeight() : 0;\n    headerPanelHeight && this._headerScrollable && this._headerScrollable.$element().height(headerPanelHeight + allDayPanelHeight);\n    headerPanelHeight && this._dateTableScrollable.$element().css({\n      paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n      marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n    });\n    headerPanelHeight && this._sidebarScrollable && this._sidebarScrollable.$element().css({\n      paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n      marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n    });\n    this._$allDayTitle && this._$allDayTitle.css(\"top\", headerHeight + headerPanelHeight + \"px\");\n  },\n  _makeGroupRows: function _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupHeaderRowClass: this._getGroupRowClass(),\n      groupRowClass: this._getGroupRowClass(),\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: this._getGroupHeaderContentClass()\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getGroupCount(), groupByDate);\n  },\n  _getDateHeaderTemplate: function _getDateHeaderTemplate() {\n    return this.option(\"dateCellTemplate\");\n  },\n  _renderDateHeader: function _renderDateHeader() {\n    var $container = this._getDateHeaderContainer();\n\n    var $headerRow = $(\"<tr>\").addClass(HEADER_ROW_CLASS);\n\n    var count = this._getCellCount();\n\n    var cellTemplate = this._getDateHeaderTemplate();\n\n    var repeatCount = this._calculateHeaderCellRepeatCount();\n\n    var templateCallbacks = [];\n    var groupByDate = this.isGroupedByDate();\n    var colspan = groupByDate ? this._getGroupCount() : 1;\n    var i;\n    var j;\n\n    if (!groupByDate) {\n      for (j = 0; j < repeatCount; j++) {\n        for (i = 0; i < count; i++) {\n          this._renderDateHeaderTemplate($headerRow, i, j * repeatCount + i, cellTemplate, templateCallbacks);\n        }\n      }\n\n      $container.append($headerRow);\n    } else {\n      for (i = 0; i < count; i++) {\n        var $cell = this._renderDateHeaderTemplate($headerRow, i, i * repeatCount, cellTemplate, templateCallbacks);\n\n        $cell.attr(\"colSpan\", colspan);\n      }\n\n      $container.prepend($headerRow);\n    }\n\n    this._applyCellTemplates(templateCallbacks);\n\n    return $headerRow;\n  },\n  _renderDateHeaderTemplate: function _renderDateHeaderTemplate($container, i, calculatedIndex, cellTemplate, templateCallbacks) {\n    var text = this._getHeaderText(i);\n\n    var $cell = $(\"<th>\").addClass(this._getHeaderPanelCellClass(i)).attr(\"title\", text);\n\n    if (cellTemplate && cellTemplate.render) {\n      templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {\n        model: {\n          text: text,\n          date: this._getDateByIndex(i)\n        },\n        index: calculatedIndex,\n        container: getPublicElement($cell)\n      }));\n    } else {\n      $cell.text(text);\n    }\n\n    $container.append($cell);\n    return $cell;\n  },\n  _getHeaderPanelCellClass: function _getHeaderPanelCellClass(i) {\n    var cellClass = HEADER_PANEL_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n  },\n  _calculateHeaderCellRepeatCount: function _calculateHeaderCellRepeatCount() {\n    return this._groupedStrategy.calculateHeaderCellRepeatCount();\n  },\n  _renderAllDayPanel: function _renderAllDayPanel(index) {\n    var cellCount = this._getCellCount();\n\n    if (!this._isVerticalGroupedWorkSpace()) {\n      cellCount *= this._getGroupCount() || 1;\n    }\n\n    var cellTemplates = this._renderTableBody({\n      container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),\n      rowCount: 1,\n      cellCount: cellCount,\n      cellClass: this._getAllDayPanelCellClass.bind(this),\n      rowClass: ALL_DAY_TABLE_ROW_CLASS,\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: this._getAllDayCellData.bind(this),\n      groupIndex: index\n    }, true);\n\n    this._toggleAllDayVisibility();\n\n    this._applyCellTemplates(cellTemplates);\n  },\n  _getAllDayPanelCellClass: function _getAllDayPanelCellClass(i, j) {\n    var cellClass = ALL_DAY_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);\n  },\n  _getAllDayCellData: function _getAllDayCellData(cell, rowIndex, cellIndex, groupIndex) {\n    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);\n\n    startDate = dateUtils.trimTime(startDate);\n    var data = {\n      startDate: startDate,\n      endDate: new Date(startDate.getTime() + DAY_MS),\n      allDay: true\n    };\n\n    var groups = this._getCellGroups(groupIndex || this._getGroupIndex(rowIndex, cellIndex));\n\n    if (groups.length) {\n      data.groups = {};\n    }\n\n    for (var i = 0; i < groups.length; i++) {\n      data.groups[groups[i].name] = groups[i].id;\n    }\n\n    return {\n      key: CELL_DATA,\n      value: data\n    };\n  },\n  _toggleAllDayVisibility: function _toggleAllDayVisibility() {\n    var showAllDayPanel = this.option(\"showAllDayPanel\");\n\n    this._$allDayPanel.toggle(showAllDayPanel);\n\n    this._$allDayTitle && this._$allDayTitle.toggleClass(ALL_DAY_TITLE_HIDDEN_CLASS, !showAllDayPanel);\n    this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);\n\n    this._changeAllDayVisibility();\n\n    this._updateScrollable();\n  },\n  _changeAllDayVisibility: function _changeAllDayVisibility() {\n    this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option(\"allDayExpanded\") && this.option(\"showAllDayPanel\"));\n  },\n  _updateScrollable: function _updateScrollable() {\n    this._dateTableScrollable.update();\n\n    this._headerScrollable && this._headerScrollable.update();\n    this._sidebarScrollable && this._sidebarScrollable.update();\n  },\n  _renderTimePanel: function _renderTimePanel() {\n    var _this5 = this;\n\n    var repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();\n\n    var startViewDate = this._getDateWithSkippedDST();\n\n    var _getTimeText = function _getTimeText(i) {\n      var index = i % _this5._getRowCount();\n\n      if (index % 2 === 0) {\n        return dateLocalization.format(_this5._getTimeCellDateCore(startViewDate, i), \"shorttime\");\n      }\n\n      return \"\";\n    };\n\n    this._renderTableBody({\n      container: getPublicElement(this._$timePanel),\n      rowCount: this._getTimePanelRowCount() * repeatCount,\n      cellCount: 1,\n      cellClass: this._getTimeCellClass.bind(this),\n      rowClass: TIME_PANEL_ROW_CLASS,\n      cellTemplate: this.option(\"timeCellTemplate\"),\n      getCellText: _getTimeText.bind(this),\n      getCellDate: this._getTimeCellDate.bind(this),\n      groupCount: this._getGroupCount(),\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0\n    });\n  },\n  _getDateWithSkippedDST: function _getDateWithSkippedDST() {\n    var result = new Date(this.getStartViewDate());\n\n    if (timeZoneUtils.isTimezoneChangeInDate(result)) {\n      result = new Date(result.setDate(result.getDate() + 1));\n    }\n\n    return result;\n  },\n  _getTimePanelRowCount: function _getTimePanelRowCount() {\n    return this._getCellCountInDay();\n  },\n  _getCellCountInDay: function _getCellCountInDay(skipRound) {\n    var result = this._calculateDayDuration() / this.option(\"hoursInterval\");\n    return skipRound ? result : Math.ceil(result);\n  },\n  _calculateDayDuration: function _calculateDayDuration() {\n    return this.option(\"endDayHour\") - this.option(\"startDayHour\");\n  },\n  _getTimeCellClass: function _getTimeCellClass(i) {\n    var cellClass = TIME_PANEL_CELL_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n    return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i);\n  },\n  _getTimeCellDateAdjustedDST: function _getTimeCellDateAdjustedDST(i) {\n    var startViewDate = new Date(this.getStartViewDate());\n\n    if (timeZoneUtils.isTimezoneChangeInDate(startViewDate)) {\n      startViewDate = new Date(startViewDate.setDate(startViewDate.getDate() + 1));\n    }\n\n    return this._getTimeCellDateCore(startViewDate, i);\n  },\n  _getTimeCellDate: function _getTimeCellDate(i) {\n    return this._getTimeCellDateCore(this.getStartViewDate(), i);\n  },\n  _getTimeCellDateCore: function _getTimeCellDateCore(startViewDate, i) {\n    var result = new Date(startViewDate);\n    var timeCellDuration = Math.round(this.getCellDuration());\n\n    var cellCountInDay = this._getCellCountInDay(true);\n\n    result.setMilliseconds(result.getMilliseconds() + timeCellDuration * (i % cellCountInDay));\n    return result;\n  },\n  _renderDateTable: function _renderDateTable() {\n    var groupCount = this._getGroupCount();\n\n    this._renderTableBody({\n      container: getPublicElement(this._$dateTable),\n      rowCount: this._getTotalRowCount(groupCount),\n      cellCount: this._getTotalCellCount(groupCount),\n      cellClass: this._getDateTableCellClass.bind(this),\n      rowClass: this._getDateTableRowClass(),\n      cellTemplate: this.option(\"dataCellTemplate\"),\n      getCellData: this._getCellData.bind(this),\n      allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,\n      groupCount: groupCount,\n      groupByDate: this.option(\"groupByDate\")\n    });\n  },\n  _insertAllDayRowsIntoDateTable: function _insertAllDayRowsIntoDateTable() {\n    return this._groupedStrategy.insertAllDayRowsIntoDateTable();\n  },\n  _getTotalCellCount: function _getTotalCellCount(groupCount) {\n    return this._groupedStrategy.getTotalCellCount(groupCount);\n  },\n  _getTotalRowCount: function _getTotalRowCount() {\n    return this._groupedStrategy.getTotalRowCount();\n  },\n  _getCellData: function _getCellData(cell, rowIndex, cellIndex) {\n    var data = this._prepareCellData(rowIndex, cellIndex, cell);\n\n    return {\n      key: CELL_DATA,\n      value: data\n    };\n  },\n  _prepareCellData: function _prepareCellData(rowIndex, cellIndex) {\n    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);\n\n    var endDate = this.calculateEndDate(startDate);\n    var data = {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: this._getTableAllDay()\n    };\n\n    var groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));\n\n    if (groups.length) {\n      data.groups = {};\n    }\n\n    for (var i = 0; i < groups.length; i++) {\n      data.groups[groups[i].name] = groups[i].id;\n    }\n\n    return data;\n  },\n  _getGroupIndex: function _getGroupIndex(rowIndex, cellIndex) {\n    return this._groupedStrategy.getGroupIndex(rowIndex, cellIndex);\n  },\n  _getTableAllDay: function _getTableAllDay() {\n    return false;\n  },\n  calculateEndDate: function calculateEndDate(startDate) {\n    var result = new Date(startDate);\n    result.setMilliseconds(result.getMilliseconds() + Math.round(this._getInterval()));\n    return result;\n  },\n  _getGroupCount: function _getGroupCount() {\n    var groups = this.option(\"groups\");\n    var result = 0;\n\n    for (var i = 0, len = groups.length; i < len; i++) {\n      if (!i) {\n        result = groups[i].items.length;\n      } else {\n        result *= groups[i].items.length;\n      }\n    }\n\n    return result;\n  },\n  _getPathToLeaf: function _getPathToLeaf(leafIndex) {\n    var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n\n    function findLeafByIndex(data, index) {\n      for (var i = 0; i < data.length; i++) {\n        if (data[i].leafIndex === index) {\n          return data[i];\n        } else {\n          var _leaf = findLeafByIndex(data[i].children, index);\n\n          if (_leaf) {\n            return _leaf;\n          }\n        }\n      }\n    }\n\n    function makeBranch(leaf, result) {\n      result = result || [];\n      result.push(leaf.value);\n\n      if (leaf.parent) {\n        makeBranch(leaf.parent, result);\n      }\n\n      return result;\n    }\n\n    var leaf = findLeafByIndex(tree, leafIndex);\n    return makeBranch(leaf).reverse();\n  },\n  _getCellGroups: function _getCellGroups(groupIndex) {\n    var result = [];\n\n    if (this._getGroupCount()) {\n      var groups = this.option(\"groups\");\n\n      if (groupIndex < 0) {\n        return;\n      }\n\n      var path = this._getPathToLeaf(groupIndex);\n\n      for (var i = 0; i < groups.length; i++) {\n        result.push({\n          name: groups[i].name,\n          id: path[i]\n        });\n      }\n    }\n\n    return result;\n  },\n  _attachTablesEvents: function _attachTablesEvents() {\n    var _this6 = this;\n\n    var that = this;\n    var isPointerDown = false;\n    var cellHeight;\n    var cellWidth;\n    var $element = this.$element();\n    eventsEngine.off($element, SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXDRAGLEAVE_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXDROP_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);\n    eventsEngine.off($element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);\n    eventsEngine.on($element, SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME, SCHEDULER_DRAG_AND_DROP_SELECTOR, {\n      itemSizeFunc: function itemSizeFunc($element) {\n        if (!cellHeight) {\n          cellHeight = getBoundingRect($element.get(0)).height;\n        }\n\n        if (!cellWidth) {\n          cellWidth = getBoundingRect($element.get(0)).width;\n        }\n\n        return {\n          width: cellWidth,\n          height: cellHeight\n        };\n      },\n      checkDropTarget: function checkDropTarget(target, event) {\n        return !_this6._isOutsideScrollable(target, event);\n      }\n    }, function (e) {\n      if (that._$currentTableTarget) {\n        that.removeDroppableCellClass(that._$currentTableTarget);\n      }\n\n      that._$currentTableTarget = $(e.target);\n\n      that._$currentTableTarget.addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXDRAGLEAVE_EVENT_NAME, function (e) {\n      if (!$element.find($(e.draggingElement)).length) {\n        that.removeDroppableCellClass();\n      }\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXDROP_EVENT_NAME, SCHEDULER_DRAG_AND_DROP_SELECTOR, function (e) {\n      that.removeDroppableCellClass($(e.target));\n      cellHeight = 0;\n      cellWidth = 0;\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, SCHEDULER_DRAG_AND_DROP_SELECTOR, function (e) {\n      if (eventUtils.isMouseEvent(e) && 1 === e.which) {\n        isPointerDown = true;\n        that.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n        eventsEngine.on(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, function () {\n          isPointerDown = false;\n          that.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n        });\n      }\n    });\n    eventsEngine.on($element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, SCHEDULER_DRAG_AND_DROP_SELECTOR, function (e) {\n      if (isPointerDown && that._dateTableScrollable && !that._dateTableScrollable.option(\"scrollByContent\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        that._moveToCell($(e.target), true);\n      }\n    });\n  },\n  _getDateTables: function _getDateTables() {\n    return this._$dateTable.add(this._$allDayTable);\n  },\n  _getDateTable: function _getDateTable() {\n    return this._$dateTable;\n  },\n  _getAllDayTable: function _getAllDayTable() {\n    return this._$allDayTable;\n  },\n  _getInterval: function _getInterval() {\n    if (void 0 === this._interval) {\n      this._interval = this.option(\"hoursInterval\") * HOUR_MS;\n    }\n\n    return this._interval;\n  },\n  _getHeaderText: function _getHeaderText(headerIndex) {\n    return dateLocalization.format(this._getDateByIndex(headerIndex), this._getFormat());\n  },\n  _getDateByIndex: abstract,\n  _getFormat: abstract,\n  _calculateCellIndex: function _calculateCellIndex(rowIndex, cellIndex) {\n    return this._groupedStrategy.calculateCellIndex(rowIndex, cellIndex);\n  },\n  _renderTableBody: function _renderTableBody(options, delayCellTemplateRendering) {\n    var result = [];\n\n    if (!delayCellTemplateRendering) {\n      this._applyCellTemplates(tableCreator.makeTable(options));\n    } else {\n      result = tableCreator.makeTable(options);\n    }\n\n    return result;\n  },\n  _removeAllDayElements: function _removeAllDayElements() {\n    this._$allDayTable && this._$allDayTable.remove();\n    this._$allDayTitle && this._$allDayTitle.remove();\n  },\n  _cleanView: function _cleanView() {\n    this._cleanCellDataCache();\n\n    this._cleanAllowedPositions();\n\n    this._$thead.empty();\n\n    this._$dateTable.empty();\n\n    this._shader && this._shader.clean();\n\n    this._$timePanel.empty();\n\n    this._$allDayTable && this._$allDayTable.empty();\n\n    this._$groupTable.empty();\n\n    delete this._hiddenInterval;\n    delete this._interval;\n  },\n  _clean: function _clean() {\n    eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n    this.callBase();\n  },\n  getWorkArea: function getWorkArea() {\n    return this._dateTableScrollable.$content();\n  },\n  getScrollable: function getScrollable() {\n    return this._dateTableScrollable;\n  },\n  getScrollableScrollTop: function getScrollableScrollTop() {\n    return this._dateTableScrollable.scrollTop();\n  },\n  getGroupedScrollableScrollTop: function getGroupedScrollableScrollTop(allDay) {\n    return this._groupedStrategy.getScrollableScrollTop(allDay);\n  },\n  getScrollableScrollLeft: function getScrollableScrollLeft() {\n    return this._dateTableScrollable.scrollLeft();\n  },\n  getScrollableOuterWidth: function getScrollableOuterWidth() {\n    return this._dateTableScrollable.scrollWidth();\n  },\n  getScrollableContainer: function getScrollableContainer() {\n    return this._dateTableScrollable._container();\n  },\n  getHeaderPanelHeight: function getHeaderPanelHeight() {\n    return this._$headerPanel && this._$headerPanel.outerHeight(true);\n  },\n  getTimePanelWidth: function getTimePanelWidth() {\n    return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;\n  },\n  getGroupTableWidth: function getGroupTableWidth() {\n    return this._$groupTable ? this._$groupTable.outerWidth() : 0;\n  },\n  getWorkSpaceLeftOffset: function getWorkSpaceLeftOffset() {\n    return this._groupedStrategy.getLeftOffset();\n  },\n  getGroupedStrategy: function getGroupedStrategy() {\n    return this._groupedStrategy;\n  },\n  _getCellCoordinatesByIndex: function _getCellCoordinatesByIndex(index) {\n    var cellIndex = Math.floor(index / this._getRowCount());\n    var rowIndex = index - this._getRowCount() * cellIndex;\n    return {\n      cellIndex: cellIndex,\n      rowIndex: rowIndex\n    };\n  },\n  _getDateByCellIndexes: function _getDateByCellIndexes(rowIndex, cellIndex, patchedIndexes) {\n    cellIndex = !patchedIndexes ? this._patchCellIndex(cellIndex) : cellIndex;\n    var firstViewDate = this.getStartViewDate();\n    var currentDate = new Date(firstViewDate.getTime() + this._getMillisecondsOffset(rowIndex, cellIndex) + this._getOffsetByCount(cellIndex));\n    currentDate.setTime(currentDate.getTime() + dateUtils.getTimezonesDifference(firstViewDate, currentDate));\n    return currentDate;\n  },\n  _patchCellIndex: function _patchCellIndex(cellIndex) {\n    if (this.isGroupedByDate()) {\n      cellIndex = Math.floor(cellIndex / this._getGroupCount());\n    }\n\n    return cellIndex;\n  },\n  _getOffsetByCount: function _getOffsetByCount() {\n    return 0;\n  },\n  _getMillisecondsOffset: function _getMillisecondsOffset(rowIndex, cellIndex) {\n    return this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex) + this._calculateHiddenInterval(rowIndex, cellIndex);\n  },\n  _calculateHiddenInterval: function _calculateHiddenInterval(rowIndex, cellIndex) {\n    var dayCount = cellIndex % this._getCellCount();\n\n    return dayCount * this._getHiddenInterval();\n  },\n  _getHiddenInterval: function _getHiddenInterval() {\n    if (void 0 === this._hiddenInterval) {\n      this._hiddenInterval = DAY_MS - this.getVisibleDayDuration();\n    }\n\n    return this._hiddenInterval;\n  },\n  _getIntervalBetween: function _getIntervalBetween(currentDate, allDay) {\n    var firstViewDate = this.getStartViewDate();\n    var startDayTime = this.option(\"startDayHour\") * HOUR_MS;\n    var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n    var fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;\n\n    var days = this._getDaysOfInterval(fullInterval, startDayTime);\n\n    var weekendsCount = this._getWeekendsCount(days);\n\n    var result = (days - weekendsCount) * DAY_MS;\n\n    if (!allDay) {\n      result = fullInterval - days * this._getHiddenInterval() - weekendsCount * this.getVisibleDayDuration();\n    }\n\n    return result;\n  },\n  _getWeekendsCount: function _getWeekendsCount() {\n    return 0;\n  },\n  _getDaysOfInterval: function _getDaysOfInterval(fullInterval, startDayTime) {\n    return Math.floor((fullInterval + startDayTime) / DAY_MS);\n  },\n  _getGroupIndexes: function _getGroupIndexes(appointmentResources) {\n    var result = [];\n\n    if (appointmentResources && this.option(\"groups\").length) {\n      var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n      result = this.invoke(\"getResourceTreeLeaves\", tree, appointmentResources);\n    }\n\n    return result;\n  },\n  _updateIndex: function _updateIndex(index) {\n    return index * this._getRowCount();\n  },\n  _getDroppableCell: function _getDroppableCell() {\n    return this._getDateTables().find(\".\" + DATE_TABLE_DROPPABLE_CELL_CLASS);\n  },\n  _getWorkSpaceWidth: function _getWorkSpaceWidth() {\n    if (this._needCreateCrossScrolling()) {\n      return getBoundingRect(this._$dateTable.get(0)).width;\n    }\n\n    return getBoundingRect(this.$element().get(0)).width - this.getTimePanelWidth();\n  },\n  _getCellPositionByIndex: function _getCellPositionByIndex(index, groupIndex, inAllDayRow) {\n    var cellCoordinates = this._getCellCoordinatesByIndex(index);\n\n    var $cell = this._getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow);\n\n    var result = this._getCellPosition($cell);\n\n    this.setCellDataCache(cellCoordinates, groupIndex, $cell);\n\n    if (result) {\n      result.rowIndex = cellCoordinates.rowIndex;\n      result.cellIndex = cellCoordinates.cellIndex;\n    }\n\n    return result;\n  },\n  _getCellPosition: function _getCellPosition($cell) {\n    var position = $cell.position();\n\n    if (this.option(\"rtlEnabled\")) {\n      position.left += getBoundingRect($cell.get(0)).width;\n    }\n\n    return position;\n  },\n  _getCellByCoordinates: function _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);\n\n    return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.cellIndex);\n  },\n  _getCells: function _getCells(allDay, direction) {\n    var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n\n    if (\"vertical\" === direction) {\n      var result = [];\n\n      for (var i = 1;; i++) {\n        var cells = this.$element().find(\"tr .\".concat(cellClass, \":nth-child(\").concat(i, \")\"));\n\n        if (!cells.length) {\n          break;\n        }\n\n        result = result.concat(cells.toArray());\n      }\n\n      return $(result);\n    } else {\n      return this.$element().find(\".\" + cellClass);\n    }\n  },\n  _setHorizontalGroupHeaderCellsHeight: function _setHorizontalGroupHeaderCellsHeight() {\n    var height = getBoundingRect(this._$dateTable.get(0)).height;\n\n    this._$groupTable.outerHeight(height);\n  },\n  _getDateTableBorder: function _getDateTableBorder() {\n    return DATE_TABLE_CELL_BORDER;\n  },\n  _getDateTableBorderOffset: function _getDateTableBorderOffset() {\n    return 2 * this._getDateTableBorder();\n  },\n  _getGroupHeaderCellsContent: function _getGroupHeaderCellsContent() {\n    return this.$element().find(\".\" + GROUP_HEADER_CONTENT_CLASS);\n  },\n  _getGroupHeaderCells: function _getGroupHeaderCells() {\n    return this.$element().find(\".\" + GROUP_HEADER_CLASS);\n  },\n  _getScrollCoordinates: function _getScrollCoordinates(hours, minutes, date) {\n    var currentDate = date || new Date(this.option(\"currentDate\"));\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n\n    if (hours < startDayHour) {\n      hours = startDayHour;\n    }\n\n    if (hours >= endDayHour) {\n      hours = endDayHour - 1;\n    }\n\n    currentDate.setHours(hours, minutes, 0, 0);\n    return this.getCoordinatesByDate(currentDate);\n  },\n  _isOutsideScrollable: function _isOutsideScrollable(target, event) {\n    var $dateTableScrollableElement = this._dateTableScrollable.$element();\n\n    var scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));\n    var window = windowUtils.getWindow();\n    var isTargetInAllDayPanel = !$(target).closest($dateTableScrollableElement).length;\n    var isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window.scrollX || 0);\n    var isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window.scrollY || 0);\n\n    if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {\n      return false;\n    }\n\n    return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;\n  },\n  setCellDataCache: function setCellDataCache(cellCoordinates, groupIndex, $cell) {\n    var cache = this.getCellDataCache();\n    var data = this.getCellData($cell);\n    var key = JSON.stringify({\n      rowIndex: cellCoordinates.rowIndex,\n      cellIndex: cellCoordinates.cellIndex,\n      groupIndex: groupIndex\n    });\n    cache[key] = data;\n  },\n  setCellDataCacheAlias: function setCellDataCacheAlias(appointment, geometry) {\n    var key = JSON.stringify({\n      rowIndex: appointment.rowIndex,\n      cellIndex: appointment.cellIndex,\n      groupIndex: appointment.groupIndex\n    });\n    var aliasKey = JSON.stringify({\n      top: geometry.top,\n      left: geometry.left\n    });\n    var cache = this.getCellDataCache();\n\n    if (cache[key]) {\n      cache[aliasKey] = cache[key];\n    }\n  },\n  getCellDataCache: function getCellDataCache(key) {\n    if (!this._cache) {\n      this._cache = {};\n    }\n\n    return key ? this._cache[key] : this._cache;\n  },\n  _cleanCellDataCache: function _cleanCellDataCache() {\n    delete this._cache;\n  },\n  _cleanAllowedPositions: function _cleanAllowedPositions() {\n    delete this._maxAllowedVerticalPosition;\n    delete this._maxAllowedPosition;\n  },\n  supportAllDayRow: function supportAllDayRow() {\n    return true;\n  },\n  keepOriginalHours: function keepOriginalHours() {\n    return false;\n  },\n  getFocusedCellData: function getFocusedCellData() {\n    var $focusedCells = this._getAllFocusedCells();\n\n    var result = [];\n\n    if ($focusedCells.length > 1) {\n      result = this._getMultipleCellsData($focusedCells);\n    } else {\n      var data = this.getCellData($focusedCells);\n      data && result.push(data);\n    }\n\n    return result;\n  },\n  _getMultipleCellsData: function _getMultipleCellsData($cells) {\n    var data = [];\n\n    for (var i = 0; i < $cells.length; i++) {\n      data.push(dataUtils.data($cells[i], CELL_DATA));\n    }\n\n    return data;\n  },\n  getCellData: function getCellData($cell) {\n    var data = $cell[0] ? dataUtils.data($cell[0], CELL_DATA) : void 0;\n    return extend(true, {}, data);\n  },\n  _getHorizontalMax: function _getHorizontalMax(groupIndex) {\n    groupIndex = this.isGroupedByDate() ? this._getGroupCount() - 1 : groupIndex;\n    return this._groupedStrategy.getHorizontalMax(groupIndex);\n  },\n  getCoordinatesByDate: function getCoordinatesByDate(date, groupIndex, inAllDayRow) {\n    groupIndex = groupIndex || 0;\n    var index = this.getCellIndexByDate(date, inAllDayRow);\n\n    var position = this._getCellPositionByIndex(index, groupIndex, inAllDayRow);\n\n    var shift = this.getPositionShift(inAllDayRow ? 0 : this.getTimeShift(date), inAllDayRow);\n\n    var horizontalHMax = this._getHorizontalMax(groupIndex, date);\n\n    if (!position) {\n      throw errors.Error(\"E1039\");\n    }\n\n    var coordinates = {\n      cellPosition: position.left + shift.cellPosition,\n      top: position.top + shift.top,\n      left: position.left + shift.left,\n      rowIndex: position.rowIndex,\n      cellIndex: position.cellIndex,\n      hMax: horizontalHMax,\n      vMax: this.getVerticalMax(groupIndex),\n      groupIndex: groupIndex\n    };\n    return coordinates;\n  },\n  getVerticalMax: function getVerticalMax(groupIndex) {\n    return this._groupedStrategy.getVerticalMax(groupIndex);\n  },\n  _getOffsetByAllDayPanel: function _getOffsetByAllDayPanel(groupIndex) {\n    return this._groupedStrategy._getOffsetByAllDayPanel(groupIndex);\n  },\n  _getGroupTop: function _getGroupTop(groupIndex) {\n    return this._groupedStrategy._getGroupTop(groupIndex);\n  },\n  isGroupedByDate: function isGroupedByDate() {\n    return this.option(\"groupByDate\") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;\n  },\n  getCellIndexByDate: function getCellIndexByDate(date, inAllDayRow) {\n    var timeInterval = inAllDayRow ? 864e5 : this._getInterval();\n\n    var dateTimeStamp = this._getIntervalBetween(date, inAllDayRow);\n\n    var index = Math.floor(dateTimeStamp / timeInterval);\n\n    if (inAllDayRow) {\n      index = this._updateIndex(index);\n    }\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    return index;\n  },\n  getPositionShift: function getPositionShift(timeShift, isAllDay) {\n    return {\n      top: timeShift * this.getCellHeight(),\n      left: 0,\n      cellPosition: 0\n    };\n  },\n  getTimeShift: function getTimeShift(date) {\n    var currentDayStart = new Date(date);\n    var cellDuration = this.getCellDuration();\n    var currentDayEndHour = new Date(new Date(date).setHours(this.option(\"endDayHour\"), 0, 0));\n\n    if (date.getTime() <= currentDayEndHour.getTime()) {\n      currentDayStart.setHours(this.option(\"startDayHour\"), 0, 0, 0);\n    }\n\n    var currentDateTime = date.getTime();\n    var currentDayStartTime = currentDayStart.getTime();\n\n    var minTime = this._firstViewDate.getTime();\n\n    return currentDateTime > minTime ? (currentDateTime - currentDayStartTime) % cellDuration / cellDuration : 0;\n  },\n  _isSkippedData: function _isSkippedData() {\n    return false;\n  },\n  getCoordinatesByDateInGroup: function getCoordinatesByDateInGroup(date, appointmentResources, inAllDayRow) {\n    var indexes = this._getGroupIndexes(appointmentResources);\n\n    var result = [];\n\n    if (this._isSkippedData(date)) {\n      return result;\n    }\n\n    if (indexes.length) {\n      for (var i = 0; i < indexes.length; i++) {\n        result.push(this.getCoordinatesByDate(date, indexes[i], inAllDayRow));\n      }\n    } else {\n      result.push(this.getCoordinatesByDate(date, 0, inAllDayRow));\n    }\n\n    return result;\n  },\n  getDroppableCellIndex: function getDroppableCellIndex() {\n    var $droppableCell = this._getDroppableCell();\n\n    var $row = $droppableCell.parent();\n    var rowIndex = $row.index();\n    return rowIndex * $row.find(\"td\").length + $droppableCell.index();\n  },\n  getDataByDroppableCell: function getDataByDroppableCell() {\n    var cellData = this.getCellData(this._getDroppableCell());\n    var allDay = cellData.allDay;\n    var startDate = cellData.startDate;\n    var endDate = startDate && this.invoke(\"calculateAppointmentEndDate\", allDay, startDate);\n    return {\n      startDate: startDate,\n      endDate: endDate,\n      allDay: allDay,\n      groups: cellData.groups\n    };\n  },\n  getDateRange: function getDateRange() {\n    return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];\n  },\n  getCellWidth: function getCellWidth() {\n    var cell = this._getCells().first().get(0);\n\n    return cell && getBoundingRect(cell).width;\n  },\n  getCellMinWidth: function getCellMinWidth() {\n    return DATE_TABLE_MIN_CELL_WIDTH;\n  },\n  getRoundedCellWidth: function getRoundedCellWidth(groupIndex, startIndex, cellCount) {\n    if (groupIndex < 0) {\n      return 0;\n    }\n\n    var $row = this.$element().find(\".\" + this._getDateTableRowClass()).eq(0);\n    var width = 0;\n    var $cells = $row.find(\".\" + DATE_TABLE_CELL_CLASS);\n    var totalCellCount = this._getCellCount() * groupIndex;\n    cellCount = cellCount || this._getCellCount();\n\n    if (!typeUtils.isDefined(startIndex)) {\n      startIndex = totalCellCount;\n    }\n\n    for (var i = startIndex; i < totalCellCount + cellCount; i++) {\n      width += getBoundingRect($($cells).eq(i).get(0)).width;\n    }\n\n    return width / (totalCellCount + cellCount - startIndex);\n  },\n  getCellHeight: function getCellHeight() {\n    var cell = this._getCells().first().get(0);\n\n    return cell && getBoundingRect(cell).height;\n  },\n  getAllDayHeight: function getAllDayHeight() {\n    var cell = this._getCells(true).first().get(0);\n\n    return this.option(\"showAllDayPanel\") ? cell && getBoundingRect(cell).height || 0 : 0;\n  },\n  getAllDayOffset: function getAllDayOffset() {\n    return this._groupedStrategy.getAllDayOffset();\n  },\n  getMaxAllowedPosition: function getMaxAllowedPosition() {\n    if (!this._maxAllowedPosition) {\n      var isRtl = this.option(\"rtlEnabled\");\n      this._maxAllowedPosition = [];\n\n      this._$dateTable.find(\"tr\").first().find(\"td:nth-child(\" + this._getCellCount() + \"n)\").each(function (_, cell) {\n        var maxPosition = $(cell).position().left;\n\n        if (!isRtl) {\n          maxPosition += getBoundingRect(cell).width;\n        }\n\n        this._maxAllowedPosition.push(Math.round(maxPosition));\n      }.bind(this));\n    }\n\n    return this._maxAllowedPosition;\n  },\n  getMaxAllowedVerticalPosition: function getMaxAllowedVerticalPosition() {\n    if (!this._maxAllowedVerticalPosition) {\n      var that = this;\n      this._maxAllowedVerticalPosition = [];\n\n      var rows = this._getRowCount();\n\n      this._$dateTable.find(\"tr:nth-child(\" + rows + \"n)\").each(function (_, row) {\n        var maxPosition = $(row).position().top + getBoundingRect(row).height;\n\n        that._maxAllowedVerticalPosition.push(Math.round(maxPosition));\n      });\n    }\n\n    return this._maxAllowedVerticalPosition;\n  },\n  getFixedContainer: function getFixedContainer() {\n    return this._$fixedContainer;\n  },\n  getAllDayContainer: function getAllDayContainer() {\n    return this._$allDayContainer;\n  },\n  getCellIndexByCoordinates: function getCellIndexByCoordinates(coordinates, allDay) {\n    var cellCount = this._getTotalCellCount(this._getGroupCount());\n\n    var cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount);\n    var cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();\n    var leftOffset = this._isRTL() || this.option(\"crossScrollingEnabled\") ? 0 : this.getWorkSpaceLeftOffset();\n    var topIndex = Math.floor(Math.floor(coordinates.top) / Math.floor(cellHeight));\n    var leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);\n\n    if (this._isRTL()) {\n      leftIndex = cellCount - leftIndex - 1;\n    }\n\n    return cellCount * topIndex + leftIndex;\n  },\n  getStartViewDate: function getStartViewDate() {\n    return this._firstViewDate;\n  },\n  getEndViewDate: function getEndViewDate() {\n    var dateOfLastViewCell = this.getDateOfLastViewCell();\n    var endDateOfLastViewCell = this.calculateEndViewDate(dateOfLastViewCell);\n    return this._adjustEndViewDateByDaylightDiff(dateOfLastViewCell, endDateOfLastViewCell);\n  },\n  getEndViewDateByEndDayHour: function getEndViewDateByEndDayHour() {\n    var dateOfLastViewCell = this.getDateOfLastViewCell();\n    var endTime = dateUtils.dateTimeFromDecimal(this.option(\"endDayHour\"));\n    var endDateOfLastViewCell = new Date(dateOfLastViewCell.setHours(endTime.hours, endTime.minutes));\n    return this._adjustEndViewDateByDaylightDiff(dateOfLastViewCell, endDateOfLastViewCell);\n  },\n  calculateEndViewDate: function calculateEndViewDate(dateOfLastViewCell) {\n    return new Date(dateOfLastViewCell.getTime() + this.getCellDuration());\n  },\n  _adjustEndViewDateByDaylightDiff: function _adjustEndViewDateByDaylightDiff(startDate, endDate) {\n    var daylightDiff = timeZoneUtils.getDaylightOffsetInMs(startDate, endDate);\n    var endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);\n    return new Date(endDateOfLastViewCell.getTime() - toMs(\"minute\"));\n  },\n  getDateOfLastViewCell: function getDateOfLastViewCell() {\n    var rowIndex = this._getRowCount() - 1;\n\n    var cellIndex = this._getCellCount();\n\n    if (this.isGroupedByDate()) {\n      cellIndex = cellIndex * this._getGroupCount() - 1;\n    } else {\n      cellIndex -= 1;\n    }\n\n    return this._getDateByCellIndexes(rowIndex, cellIndex, true);\n  },\n  getCellDuration: function getCellDuration() {\n    return 36e5 * this.option(\"hoursInterval\");\n  },\n  getIntervalDuration: function getIntervalDuration(allDay) {\n    return allDay ? toMs(\"day\") : this.getCellDuration();\n  },\n  getVisibleDayDuration: function getVisibleDayDuration() {\n    return this.option(\"hoursInterval\") * this._getCellCountInDay() * HOUR_MS;\n  },\n  getGroupBounds: function getGroupBounds(coordinates) {\n    var cellCount = this._getCellCount();\n\n    var $cells = this._getCells();\n\n    var cellWidth = this.getCellWidth();\n\n    var result = this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates);\n\n    if (this._isRTL()) {\n      var startOffset = result.left;\n      result.left = result.right - 2 * cellWidth;\n      result.right = startOffset + 2 * cellWidth;\n    }\n\n    return result;\n  },\n  needRecalculateResizableArea: function needRecalculateResizableArea() {\n    return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();\n  },\n  getCellDataByCoordinates: function getCellDataByCoordinates(coordinates, allDay) {\n    var key = JSON.stringify({\n      top: coordinates.top,\n      left: coordinates.left\n    });\n    var data = this.getCellDataCache(key);\n\n    if (data) {\n      return data;\n    }\n\n    var $cells = this._getCells(allDay);\n\n    var cellIndex = this.getCellIndexByCoordinates(coordinates, allDay);\n    var $cell = $cells.eq(cellIndex);\n    return this.getCellData($cell);\n  },\n  getVisibleBounds: function getVisibleBounds() {\n    var result = {};\n    var $scrollable = this.getScrollable().$element();\n    var cellHeight = this.getCellHeight();\n    var scrolledCellCount = this.getScrollableScrollTop() / cellHeight;\n    var totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;\n    result.top = {\n      hours: Math.floor(scrolledCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: scrolledCellCount % 2 ? 30 : 0\n    };\n    result.bottom = {\n      hours: Math.floor(totalCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n      minutes: Math.floor(totalCellCount) % 2 ? 30 : 0\n    };\n    return result;\n  },\n  updateScrollPosition: function updateScrollPosition(date) {\n    date = this.invoke(\"convertDateByTimezone\", date);\n    var bounds = this.getVisibleBounds();\n    var startDateHour = date.getHours();\n    var startDateMinutes = date.getMinutes();\n\n    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds, date)) {\n      this.scrollToTime(startDateHour, startDateMinutes, date);\n    }\n  },\n  needUpdateScrollPosition: function needUpdateScrollPosition(hours, minutes, bounds) {\n    var isUpdateNeeded = false;\n\n    if (hours < bounds.top.hours || hours > bounds.bottom.hours) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.top.hours && minutes < bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  getGroupWidth: function getGroupWidth(groupIndex) {\n    var result = this._getCellCount() * this.getCellWidth();\n    var position = this.getMaxAllowedPosition();\n    var currentPosition = position[groupIndex];\n\n    if (position.length && currentPosition) {\n      if (this._isRTL()) {\n        result = currentPosition - position[groupIndex + 1];\n      } else {\n        if (0 === groupIndex) {\n          result = currentPosition;\n        } else {\n          result = currentPosition - position[groupIndex - 1];\n        }\n      }\n    }\n\n    return result;\n  },\n  scrollToTime: function scrollToTime(hours, minutes, date) {\n    var min = this.getStartViewDate();\n    var max = this.getEndViewDate();\n\n    if (date < min || date > max) {\n      errors.log(\"W1008\", date);\n      return;\n    }\n\n    var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n    var scrollable = this.getScrollable();\n    scrollable.scrollBy({\n      top: coordinates.top - scrollable.scrollTop(),\n      left: 0\n    });\n  },\n  getDistanceBetweenCells: function getDistanceBetweenCells(startIndex, endIndex) {\n    var result = 0;\n    this.$element().find(\".\" + this._getDateTableRowClass()).first().find(\".\" + DATE_TABLE_CELL_CLASS).each(function (index) {\n      if (index < startIndex || index > endIndex) {\n        return true;\n      }\n\n      result += getBoundingRect(this).width;\n    });\n    return result;\n  },\n  needApplyCollectorOffset: function needApplyCollectorOffset() {\n    return false;\n  },\n  initDragBehavior: function initDragBehavior(scheduler) {\n    if (!this.dragBehavior && scheduler) {\n      this.dragBehavior = new AppointmentDragBehavior(scheduler);\n      this.dragBehavior.addTo(this.getWorkArea());\n      this.dragBehavior.addTo(this.getAllDayContainer());\n      this.dragBehavior.addTo(this._$allDayPanel);\n    }\n  },\n  _isApplyCompactAppointmentOffset: function _isApplyCompactAppointmentOffset() {\n    return this._supportCompactDropDownAppointments();\n  },\n  _supportCompactDropDownAppointments: function _supportCompactDropDownAppointments() {\n    return true;\n  },\n  _formatWeekday: function _formatWeekday(date) {\n    return formatWeekday(date);\n  },\n  _formatWeekdayAndDay: function _formatWeekdayAndDay(date) {\n    return formatWeekday(date) + \" \" + dateLocalization.format(date, \"day\");\n  },\n  removeDroppableCellClass: function removeDroppableCellClass($cellElement) {\n    ($cellElement || this._getDroppableCell()).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n  }\n}).include(publisherMixin);\nmodule.exports = SchedulerWorkSpace;","map":null,"metadata":{},"sourceType":"script"}