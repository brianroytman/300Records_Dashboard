{"ast":null,"code":"/**\r\n * DevExtreme (ui/widget/ui.widget.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _action = require(\"../../core/action\");\n\nvar _action2 = _interopRequireDefault(_action);\n\nvar _dom_component = require(\"../../core/dom_component\");\n\nvar _dom_component2 = _interopRequireDefault(_dom_component);\n\nvar _short = require(\"../../events/short\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _extend2 = require(\"../../core/utils/extend\");\n\nvar _selectors = require(\"./selectors\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _utils = require(\"../../events/utils\");\n\nvar _type = require(\"../../core/utils/type\");\n\nrequire(\"../../events/click\");\n\nrequire(\"../../events/core/emitter.feedback\");\n\nrequire(\"../../events/hover\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction setAttribute(name, value, target) {\n  name = \"role\" === name || \"id\" === name ? name : \"aria-\".concat(name);\n  value = (0, _type.isDefined)(value) ? value.toString() : null;\n  target.attr(name, value);\n}\n\nvar Widget = _dom_component2.default.inherit({\n  _feedbackHideTimeout: 400,\n  _feedbackShowTimeout: 30,\n  _supportedKeys: function _supportedKeys() {\n    return {};\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return (0, _extend2.extend)(this.callBase(), {\n      hoveredElement: null,\n      isActive: false,\n      disabled: false,\n      visible: true,\n      hint: void 0,\n      activeStateEnabled: false,\n      onContentReady: null,\n      hoverStateEnabled: false,\n      focusStateEnabled: false,\n      tabIndex: 0,\n      accessKey: null,\n      onFocusIn: null,\n      onFocusOut: null,\n      onKeyboardHandled: null,\n      ignoreParentReadOnly: false\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initContentReadyAction();\n  },\n  _innerWidgetOptionChanged: function _innerWidgetOptionChanged(innerWidget, args) {\n    var options = Widget.getOptionsFromContainer(args);\n    innerWidget && innerWidget.option(options);\n\n    this._options.cache(args.name, options);\n  },\n  _bindInnerWidgetOptions: function _bindInnerWidgetOptions(innerWidget, optionsContainer) {\n    var _this = this;\n\n    var syncOptions = function syncOptions() {\n      return _this._options.silent(optionsContainer, (0, _extend2.extend)({}, innerWidget.option()));\n    };\n\n    syncOptions();\n    innerWidget.on(\"optionChanged\", syncOptions);\n  },\n  _getAriaTarget: function _getAriaTarget() {\n    return this._focusTarget();\n  },\n  _initContentReadyAction: function _initContentReadyAction() {\n    this._contentReadyAction = this._createActionByOption(\"onContentReady\", {\n      excludeValidators: [\"disabled\", \"readOnly\"]\n    });\n  },\n  _initMarkup: function _initMarkup() {\n    var _this$option = this.option(),\n        disabled = _this$option.disabled,\n        visible = _this$option.visible;\n\n    this.$element().addClass(\"dx-widget\");\n\n    this._toggleDisabledState(disabled);\n\n    this._toggleVisibility(visible);\n\n    this._renderHint();\n\n    this._isFocusable() && this._renderFocusTarget();\n    this.callBase();\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderContent();\n\n    this._renderFocusState();\n\n    this._attachFeedbackEvents();\n\n    this._attachHoverEvents();\n\n    this._toggleIndependentState();\n  },\n  _renderHint: function _renderHint() {\n    var _this$option2 = this.option(),\n        hint = _this$option2.hint;\n\n    this.$element().attr(\"title\", hint || null);\n  },\n  _renderContent: function _renderContent() {\n    var _this2 = this;\n\n    (0, _common.deferRender)(function () {\n      return !_this2._disposed ? _this2._renderContentImpl() : void 0;\n    }).done(function () {\n      return !_this2._disposed ? _this2._fireContentReadyAction() : void 0;\n    });\n  },\n  _renderContentImpl: _common.noop,\n  _fireContentReadyAction: (0, _common.deferRenderer)(function () {\n    return this._contentReadyAction();\n  }),\n  _dispose: function _dispose() {\n    this._contentReadyAction = null;\n\n    this._detachKeyboardEvents();\n\n    this.callBase();\n  },\n  _resetActiveState: function _resetActiveState() {\n    this._toggleActiveState(this._eventBindingTarget(), false);\n  },\n  _clean: function _clean() {\n    this._cleanFocusState();\n\n    this._resetActiveState();\n\n    this.callBase();\n    this.$element().empty();\n  },\n  _toggleVisibility: function _toggleVisibility(visible) {\n    this.$element().toggleClass(\"dx-state-invisible\", !visible);\n    this.setAria(\"hidden\", !visible || void 0);\n  },\n  _renderFocusState: function _renderFocusState() {\n    this._attachKeyboardEvents();\n\n    if (this._isFocusable()) {\n      this._renderFocusTarget();\n\n      this._attachFocusEvents();\n\n      this._renderAccessKey();\n    }\n  },\n  _renderAccessKey: function _renderAccessKey() {\n    var _this3 = this;\n\n    var $el = this._focusTarget();\n\n    var _this$option3 = this.option(),\n        accessKey = _this$option3.accessKey;\n\n    var namespace = \"UIFeedback\";\n    $el.attr(\"accesskey\", accessKey);\n\n    _short.dxClick.off($el, {\n      namespace: namespace\n    });\n\n    accessKey && _short.dxClick.on($el, function (e) {\n      if ((0, _utils.isFakeClickEvent)(e)) {\n        e.stopImmediatePropagation();\n\n        _this3.focus();\n      }\n    }, {\n      namespace: namespace\n    });\n  },\n  _isFocusable: function _isFocusable() {\n    var _this$option4 = this.option(),\n        focusStateEnabled = _this$option4.focusStateEnabled,\n        disabled = _this$option4.disabled;\n\n    return focusStateEnabled && !disabled;\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this.$element();\n  },\n  _focusTarget: function _focusTarget() {\n    return this._getActiveElement();\n  },\n  _getActiveElement: function _getActiveElement() {\n    var activeElement = this._eventBindingTarget();\n\n    if (this._activeStateUnit) {\n      return activeElement.find(this._activeStateUnit).not(\".dx-state-disabled\");\n    }\n\n    return activeElement;\n  },\n  _renderFocusTarget: function _renderFocusTarget() {\n    var _this$option5 = this.option(),\n        tabIndex = _this$option5.tabIndex;\n\n    this._focusTarget().attr(\"tabIndex\", tabIndex);\n  },\n  _keyboardEventBindingTarget: function _keyboardEventBindingTarget() {\n    return this._eventBindingTarget();\n  },\n  _refreshFocusEvent: function _refreshFocusEvent() {\n    this._detachFocusEvents();\n\n    this._attachFocusEvents();\n  },\n  _focusEventTarget: function _focusEventTarget() {\n    return this._focusTarget();\n  },\n  _focusInHandler: function _focusInHandler(event) {\n    var _this4 = this;\n\n    if (!event.isDefaultPrevented()) {\n      this._createActionByOption(\"onFocusIn\", {\n        beforeExecute: function beforeExecute() {\n          return _this4._updateFocusState(event, true);\n        },\n        excludeValidators: [\"readOnly\"]\n      })({\n        event: event\n      });\n    }\n  },\n  _focusOutHandler: function _focusOutHandler(event) {\n    var _this5 = this;\n\n    if (!event.isDefaultPrevented()) {\n      this._createActionByOption(\"onFocusOut\", {\n        beforeExecute: function beforeExecute() {\n          return _this5._updateFocusState(event, false);\n        },\n        excludeValidators: [\"readOnly\", \"disabled\"]\n      })({\n        event: event\n      });\n    }\n  },\n  _updateFocusState: function _updateFocusState(_ref, isFocused) {\n    var target = _ref.target;\n\n    if ((0, _array.inArray)(target, this._focusTarget()) !== -1) {\n      this._toggleFocusClass(isFocused, (0, _renderer2.default)(target));\n    }\n  },\n  _toggleFocusClass: function _toggleFocusClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(\"dx-state-focused\", isFocused);\n  },\n  _hasFocusClass: function _hasFocusClass(element) {\n    var $focusTarget = (0, _renderer2.default)(element || this._focusTarget());\n    return $focusTarget.hasClass(\"dx-state-focused\");\n  },\n  _isFocused: function _isFocused() {\n    return this._hasFocusClass();\n  },\n  _getKeyboardListeners: function _getKeyboardListeners() {\n    return [];\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    var _this6 = this;\n\n    this._detachKeyboardEvents();\n\n    var _this$option6 = this.option(),\n        focusStateEnabled = _this$option6.focusStateEnabled,\n        onKeyboardHandled = _this$option6.onKeyboardHandled;\n\n    var hasChildListeners = this._getKeyboardListeners().length;\n\n    var hasKeyboardEventHandler = !!onKeyboardHandled;\n    var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;\n\n    if (shouldAttach) {\n      this._keyboardListenerId = _short.keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), function (opts) {\n        return _this6._keyboardHandler(opts);\n      });\n    }\n  },\n  _keyboardHandler: function _keyboardHandler(options, onlyChildProcessing) {\n    if (!onlyChildProcessing) {\n      var originalEvent = options.originalEvent,\n          keyName = options.keyName,\n          which = options.which;\n\n      var keys = this._supportedKeys(originalEvent);\n\n      var func = keys[keyName] || keys[which];\n\n      if (void 0 !== func) {\n        var handler = func.bind(this);\n        var result = handler(originalEvent, options);\n\n        if (!result) {\n          return false;\n        }\n      }\n    }\n\n    var keyboardListeners = this._getKeyboardListeners();\n\n    var _this$option7 = this.option(),\n        onKeyboardHandled = _this$option7.onKeyboardHandled;\n\n    keyboardListeners.forEach(function (listener) {\n      return listener && listener._keyboardHandler(options);\n    });\n    onKeyboardHandled && onKeyboardHandled(options);\n    return true;\n  },\n  _refreshFocusState: function _refreshFocusState() {\n    this._cleanFocusState();\n\n    this._renderFocusState();\n  },\n  _cleanFocusState: function _cleanFocusState() {\n    var $element = this._focusTarget();\n\n    $element.removeAttr(\"tabIndex\");\n\n    this._toggleFocusClass(false);\n\n    this._detachFocusEvents();\n\n    this._detachKeyboardEvents();\n  },\n  _detachKeyboardEvents: function _detachKeyboardEvents() {\n    _short.keyboard.off(this._keyboardListenerId);\n\n    this._keyboardListenerId = null;\n  },\n  _attachHoverEvents: function _attachHoverEvents() {\n    var _this7 = this;\n\n    var _this$option8 = this.option(),\n        hoverStateEnabled = _this$option8.hoverStateEnabled;\n\n    var selector = this._activeStateUnit;\n    var namespace = \"UIFeedback\";\n\n    var $el = this._eventBindingTarget();\n\n    _short.hover.off($el, {\n      selector: selector,\n      namespace: namespace\n    });\n\n    if (hoverStateEnabled) {\n      _short.hover.on($el, new _action2.default(function (_ref2) {\n        var event = _ref2.event,\n            element = _ref2.element;\n\n        _this7._hoverStartHandler(event);\n\n        _this7.option(\"hoveredElement\", (0, _renderer2.default)(element));\n      }, {\n        excludeValidators: [\"readOnly\"]\n      }), function (event) {\n        _this7.option(\"hoveredElement\", null);\n\n        _this7._hoverEndHandler(event);\n      }, {\n        selector: selector,\n        namespace: namespace\n      });\n    }\n  },\n  _attachFeedbackEvents: function _attachFeedbackEvents() {\n    var _this8 = this;\n\n    var _this$option9 = this.option(),\n        activeStateEnabled = _this$option9.activeStateEnabled;\n\n    var selector = this._activeStateUnit;\n    var namespace = \"UIFeedback\";\n\n    var $el = this._eventBindingTarget();\n\n    _short.active.off($el, {\n      namespace: namespace,\n      selector: selector\n    });\n\n    if (activeStateEnabled) {\n      _short.active.on($el, new _action2.default(function (_ref3) {\n        var event = _ref3.event,\n            element = _ref3.element;\n        return _this8._toggleActiveState((0, _renderer2.default)(element), true, event);\n      }), new _action2.default(function (_ref4) {\n        var event = _ref4.event,\n            element = _ref4.element;\n        return _this8._toggleActiveState((0, _renderer2.default)(element), false, event);\n      }, {\n        excludeValidators: [\"disabled\", \"readOnly\"]\n      }), {\n        showTimeout: this._feedbackShowTimeout,\n        hideTimeout: this._feedbackHideTimeout,\n        selector: selector,\n        namespace: namespace\n      });\n    }\n  },\n  _detachFocusEvents: function _detachFocusEvents() {\n    var $el = this._focusEventTarget();\n\n    _short.focus.off($el, {\n      namespace: \"\".concat(this.NAME, \"Focus\")\n    });\n  },\n  _attachFocusEvents: function _attachFocusEvents() {\n    var _this9 = this;\n\n    var $el = this._focusEventTarget();\n\n    _short.focus.on($el, function (e) {\n      return _this9._focusInHandler(e);\n    }, function (e) {\n      return _this9._focusOutHandler(e);\n    }, {\n      namespace: \"\".concat(this.NAME, \"Focus\"),\n      isFocusable: function isFocusable(el) {\n        return (0, _renderer2.default)(el).is(_selectors.focusable);\n      }\n    });\n  },\n  _hoverStartHandler: _common.noop,\n  _hoverEndHandler: _common.noop,\n  _toggleActiveState: function _toggleActiveState($element, value) {\n    this.option(\"isActive\", value);\n    $element.toggleClass(\"dx-state-active\", value);\n  },\n  _updatedHover: function _updatedHover() {\n    var hoveredElement = this._options.silent(\"hoveredElement\");\n\n    this._hover(hoveredElement, hoveredElement);\n  },\n  _findHoverTarget: function _findHoverTarget($el) {\n    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());\n  },\n  _hover: function _hover($el, $previous) {\n    var _this$option10 = this.option(),\n        hoverStateEnabled = _this$option10.hoverStateEnabled,\n        disabled = _this$option10.disabled,\n        isActive = _this$option10.isActive;\n\n    $previous = this._findHoverTarget($previous);\n    $previous && $previous.toggleClass(\"dx-state-hover\", false);\n\n    if ($el && hoverStateEnabled && !disabled && !isActive) {\n      var newHoveredElement = this._findHoverTarget($el);\n\n      newHoveredElement && newHoveredElement.toggleClass(\"dx-state-hover\", true);\n    }\n  },\n  _toggleDisabledState: function _toggleDisabledState(value) {\n    this.$element().toggleClass(\"dx-state-disabled\", Boolean(value));\n    this.setAria(\"disabled\", value || void 0);\n  },\n  _toggleIndependentState: function _toggleIndependentState() {\n    this.$element().toggleClass(\"dx-state-independent\", this.option(\"ignoreParentReadOnly\"));\n  },\n  _setWidgetOption: function _setWidgetOption(widgetName, args) {\n    var _this10 = this;\n\n    if (!this[widgetName]) {\n      return;\n    }\n\n    if ((0, _type.isPlainObject)(args[0])) {\n      (0, _iterator.each)(args[0], function (option, value) {\n        return _this10._setWidgetOption(widgetName, [option, value]);\n      });\n      return;\n    }\n\n    var optionName = args[0];\n    var value = args[1];\n\n    if (1 === args.length) {\n      value = this.option(optionName);\n    }\n\n    var widgetOptionMap = this[\"\".concat(widgetName, \"OptionMap\")];\n    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);\n  },\n  _optionChanged: function _optionChanged(args) {\n    var name = args.name,\n        value = args.value,\n        previousValue = args.previousValue;\n\n    switch (name) {\n      case \"disabled\":\n        this._toggleDisabledState(value);\n\n        this._updatedHover();\n\n        this._refreshFocusState();\n\n        break;\n\n      case \"hint\":\n        this._renderHint();\n\n        break;\n\n      case \"ignoreParentReadOnly\":\n        this._toggleIndependentState();\n\n        break;\n\n      case \"activeStateEnabled\":\n        this._attachFeedbackEvents();\n\n        break;\n\n      case \"hoverStateEnabled\":\n        this._attachHoverEvents();\n\n        this._updatedHover();\n\n        break;\n\n      case \"tabIndex\":\n      case \"focusStateEnabled\":\n        this._refreshFocusState();\n\n        break;\n\n      case \"onFocusIn\":\n      case \"onFocusOut\":\n        break;\n\n      case \"accessKey\":\n        this._renderAccessKey();\n\n        break;\n\n      case \"hoveredElement\":\n        this._hover(value, previousValue);\n\n        break;\n\n      case \"isActive\":\n        this._updatedHover();\n\n        break;\n\n      case \"visible\":\n        this._toggleVisibility(value);\n\n        if (this._isVisibilityChangeSupported()) {\n          this._checkVisibilityChanged(value ? \"shown\" : \"hiding\");\n        }\n\n        break;\n\n      case \"onKeyboardHandled\":\n        this._attachKeyboardEvents();\n\n        break;\n\n      case \"onContentReady\":\n        this._initContentReadyAction();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _isVisible: function _isVisible() {\n    var _this$option11 = this.option(),\n        visible = _this$option11.visible;\n\n    return this.callBase() && visible;\n  },\n  beginUpdate: function beginUpdate() {\n    this._ready(false);\n\n    this.callBase();\n  },\n  endUpdate: function endUpdate() {\n    this.callBase();\n\n    if (this._initialized) {\n      this._ready(true);\n    }\n  },\n  _ready: function _ready(value) {\n    if (0 === arguments.length) {\n      return this._isReady;\n    }\n\n    this._isReady = value;\n  },\n  setAria: function setAria() {\n    if (!(0, _type.isPlainObject)(arguments.length <= 0 ? void 0 : arguments[0])) {\n      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());\n    } else {\n      var target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();\n\n      (0, _iterator.each)(arguments.length <= 0 ? void 0 : arguments[0], function (name, value) {\n        return setAttribute(name, value, target);\n      });\n    }\n  },\n  isReady: function isReady() {\n    return this._ready();\n  },\n  repaint: function repaint() {\n    this._refresh();\n  },\n  focus: function focus() {\n    _short.focus.trigger(this._focusTarget());\n  },\n  registerKeyHandler: function registerKeyHandler(key, handler) {\n    var currentKeys = this._supportedKeys();\n\n    this._supportedKeys = function () {\n      return (0, _extend2.extend)(currentKeys, _defineProperty({}, key, handler));\n    };\n  }\n});\n\nWidget.getOptionsFromContainer = function (_ref5) {\n  var name = _ref5.name,\n      fullName = _ref5.fullName,\n      value = _ref5.value;\n  var options = {};\n\n  if (name === fullName) {\n    options = value;\n  } else {\n    var option = fullName.split(\".\").pop();\n    options[option] = value;\n  }\n\n  return options;\n};\n\nmodule.exports = Widget;","map":null,"metadata":{},"sourceType":"script"}