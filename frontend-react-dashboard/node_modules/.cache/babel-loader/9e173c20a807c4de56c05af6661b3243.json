{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.timeline.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../../core/renderer\");\n\nvar noop = require(\"../../../core/utils/common\").noop;\n\nvar extend = require(\"../../../core/utils/extend\").extend;\n\nvar getBoundingRect = require(\"../../../core/utils/position\").getBoundingRect;\n\nvar registerComponent = require(\"../../../core/component_registrator\");\n\nvar SchedulerWorkSpace = require(\"./ui.scheduler.work_space.indicator\");\n\nvar dateUtils = require(\"../../../core/utils/date\");\n\nvar tableCreator = require(\"../ui.scheduler.table_creator\");\n\nvar HorizontalShader = require(\"../shaders/ui.scheduler.current_time_shader.horizontal\");\n\nvar TIMELINE_CLASS = \"dx-scheduler-timeline\";\nvar GROUP_TABLE_CLASS = \"dx-scheduler-group-table\";\nvar HORIZONTAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-horizontal-grouped\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_PANEL_WEEK_CELL_CLASS = \"dx-scheduler-header-panel-week-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar HORIZONTAL = \"horizontal\";\nvar DATE_TABLE_CELL_BORDER = 1;\nvar DATE_TABLE_HEADER_MARGIN = 10;\nvar toMs = dateUtils.dateToMilliseconds;\nvar SchedulerTimeline = SchedulerWorkSpace.inherit({\n  _init: function _init() {\n    this.callBase();\n    this.$element().addClass(TIMELINE_CLASS);\n    this._$sidebarTable = $(\"<div>\").addClass(GROUP_TABLE_CLASS);\n  },\n  _getCellFromNextRow: function _getCellFromNextRow(direction, isMultiSelection) {\n    if (!isMultiSelection) {\n      return this.callBase(direction, isMultiSelection);\n    }\n\n    return this._$focusedCell;\n  },\n  _getDefaultGroupStrategy: function _getDefaultGroupStrategy() {\n    return \"vertical\";\n  },\n  _toggleGroupingDirectionClass: function _toggleGroupingDirectionClass() {\n    this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      groupOrientation: \"vertical\"\n    });\n  },\n  _getRowCount: function _getRowCount() {\n    return 1;\n  },\n  _getCellCount: function _getCellCount() {\n    return this._getCellCountInDay() * this.option(\"intervalCount\");\n  },\n  getGroupTableWidth: function getGroupTableWidth() {\n    return this._$sidebarTable ? this._$sidebarTable.outerWidth() : 0;\n  },\n  _getTotalRowCount: function _getTotalRowCount(groupCount) {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._getRowCount();\n    } else {\n      groupCount = groupCount || 1;\n      return this._getRowCount() * groupCount;\n    }\n  },\n  _getDateByIndex: function _getDateByIndex(index) {\n    var resultDate = new Date(this._firstViewDate);\n    var dayIndex = Math.floor(index / this._getCellCountInDay());\n    resultDate.setTime(this._firstViewDate.getTime() + this._calculateCellIndex(0, index) * this._getInterval() + dayIndex * this._getHiddenInterval());\n    return resultDate;\n  },\n  _getFormat: function _getFormat() {\n    return \"shorttime\";\n  },\n  _needApplyLastGroupCellClass: function _needApplyLastGroupCellClass() {\n    return true;\n  },\n  _calculateHiddenInterval: function _calculateHiddenInterval(rowIndex, cellIndex) {\n    var dayIndex = Math.floor(cellIndex / this._getCellCountInDay());\n    return dayIndex * this._getHiddenInterval();\n  },\n  _getMillisecondsOffset: function _getMillisecondsOffset(rowIndex, cellIndex) {\n    cellIndex = this._calculateCellIndex(rowIndex, cellIndex);\n    return this._getInterval() * cellIndex + this._calculateHiddenInterval(rowIndex, cellIndex);\n  },\n  _createWorkSpaceElements: function _createWorkSpaceElements() {\n    this._createWorkSpaceScrollableElements();\n  },\n  _getWorkSpaceHeight: function _getWorkSpaceHeight() {\n    if (this.option(\"crossScrollingEnabled\")) {\n      return getBoundingRect(this._$dateTable.get(0)).height;\n    }\n\n    return getBoundingRect(this.$element().get(0)).height;\n  },\n  _dateTableScrollableConfig: function _dateTableScrollableConfig() {\n    var config = this.callBase();\n    var timelineConfig = {\n      direction: HORIZONTAL\n    };\n    return this.option(\"crossScrollingEnabled\") ? config : extend(config, timelineConfig);\n  },\n  _needCreateCrossScrolling: function _needCreateCrossScrolling() {\n    return true;\n  },\n  _headerScrollableConfig: function _headerScrollableConfig() {\n    var config = this.callBase();\n    return extend(config, {\n      scrollByContent: true\n    });\n  },\n  _renderTimePanel: noop,\n  _renderAllDayPanel: noop,\n  _getTableAllDay: function _getTableAllDay() {\n    return false;\n  },\n  _getDateHeaderTemplate: function _getDateHeaderTemplate() {\n    return this.option(\"timeCellTemplate\");\n  },\n  _toggleAllDayVisibility: noop,\n  _changeAllDayVisibility: noop,\n  supportAllDayRow: function supportAllDayRow() {\n    return false;\n  },\n  _getGroupHeaderContainer: function _getGroupHeaderContainer() {\n    if (this._isHorizontalGroupedWorkSpace()) {\n      return this._$thead;\n    }\n\n    return this._$sidebarTable;\n  },\n  _insertAllDayRowsIntoDateTable: function _insertAllDayRowsIntoDateTable() {\n    return false;\n  },\n  _createAllDayPanelElements: noop,\n  _renderDateHeader: function _renderDateHeader() {\n    var $headerRow = this.callBase();\n\n    if (this._needRenderWeekHeader()) {\n      var firstViewDate = new Date(this._firstViewDate);\n      var $cells = [];\n\n      var colspan = this._getCellCountInDay();\n\n      var cellTemplate = this.option(\"dateCellTemplate\");\n\n      for (var i = 0; i < this._getWeekDuration() * this.option(\"intervalCount\"); i++) {\n        var $th = $(\"<th>\");\n\n        var text = this._formatWeekdayAndDay(firstViewDate);\n\n        if (cellTemplate) {\n          var templateOptions = {\n            model: {\n              text: text,\n              date: new Date(firstViewDate)\n            },\n            container: $th,\n            index: i\n          };\n          cellTemplate.render(templateOptions);\n        } else {\n          $th.text(text);\n        }\n\n        $th.addClass(HEADER_PANEL_CELL_CLASS).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr(\"colSpan\", colspan);\n        $cells.push($th);\n\n        this._incrementDate(firstViewDate);\n      }\n\n      var $row = $(\"<tr>\").addClass(HEADER_ROW_CLASS).append($cells);\n      $headerRow.before($row);\n    }\n  },\n  _needRenderWeekHeader: function _needRenderWeekHeader() {\n    return false;\n  },\n  _incrementDate: function _incrementDate(date) {\n    date.setDate(date.getDate() + 1);\n  },\n  _getWeekDuration: function _getWeekDuration() {\n    return 1;\n  },\n  _renderView: function _renderView() {\n    this._setFirstViewDate();\n\n    var groupCellTemplates = this._renderGroupHeader();\n\n    this._renderDateHeader();\n\n    this._renderAllDayPanel();\n\n    this._renderTimePanel();\n\n    this._renderDateTable();\n\n    this._shader = new HorizontalShader(this);\n\n    this._updateGroupTableHeight();\n\n    this._$sidebarTable.appendTo(this._sidebarScrollable.$content());\n\n    this._applyCellTemplates(groupCellTemplates);\n  },\n  _setHorizontalGroupHeaderCellsHeight: noop,\n  getIndicationCellCount: function getIndicationCellCount() {\n    var today = this._getToday();\n\n    var date = this._getIndicationFirstViewDate();\n\n    var hiddenInterval = this._getHiddenInterval();\n\n    var timeDiff = today.getTime() - date.getTime();\n    var differenceInDays = Math.ceil(timeDiff / toMs(\"day\")) - 1;\n    var duration = timeDiff - differenceInDays * hiddenInterval;\n    var cellCount = duration / this.getCellDuration();\n    return cellCount;\n  },\n  getIndicationWidth: function getIndicationWidth() {\n    if (this.isGroupedByDate()) {\n      var cellCount = this.getIndicationCellCount();\n      var integerPart = Math.floor(cellCount);\n      var fractionPart = cellCount - integerPart;\n      return this.getCellWidth() * (integerPart * this._getGroupCount() + fractionPart);\n    } else {\n      return this.getIndicationCellCount() * this.getCellWidth();\n    }\n  },\n  _renderIndicator: function _renderIndicator(height, rtlOffset, $container, groupCount) {\n    var $indicator;\n    var width = this.getIndicationWidth();\n\n    if (\"vertical\" === this.option(\"groupOrientation\")) {\n      $indicator = this._createIndicator($container);\n      $indicator.height(getBoundingRect($container.get(0)).height);\n      $indicator.css(\"left\", rtlOffset ? rtlOffset - width : width);\n    } else {\n      for (var i = 0; i < groupCount; i++) {\n        var offset = this.isGroupedByDate() ? i * this.getCellWidth() : this._getCellCount() * this.getCellWidth() * i;\n        $indicator = this._createIndicator($container);\n        $indicator.height(getBoundingRect($container.get(0)).height);\n        $indicator.css(\"left\", rtlOffset ? rtlOffset - width - offset : width + offset);\n      }\n    }\n  },\n  _isVerticalShader: function _isVerticalShader() {\n    return false;\n  },\n  _isCurrentTimeHeaderCell: function _isCurrentTimeHeaderCell(headerIndex) {\n    var result = false;\n\n    if (this.option(\"showCurrentTimeIndicator\") && this._needRenderDateTimeIndicator()) {\n      var date = this._getDateByIndex(headerIndex);\n\n      var now = this._getToday();\n\n      date = new Date(date);\n\n      if (dateUtils.sameDate(now, date)) {\n        var startCellDate = new Date(date);\n        var endCellDate = new Date(date);\n        endCellDate = endCellDate.setMilliseconds(date.getMilliseconds() + this.getCellDuration());\n        result = dateUtils.dateInRange(now, startCellDate, endCellDate);\n      }\n    }\n\n    return result;\n  },\n  _cleanView: function _cleanView() {\n    this.callBase();\n\n    this._$sidebarTable.empty();\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    this.callBase(visible);\n  },\n  _setTableSizes: function _setTableSizes() {\n    var cellHeight = this.getCellHeight();\n\n    var minHeight = this._getWorkSpaceMinHeight();\n\n    var $groupCells = this._$sidebarTable.find(\"tr\");\n\n    var height = cellHeight * $groupCells.length;\n\n    if (height < minHeight) {\n      height = minHeight;\n    }\n\n    this._$sidebarTable.height(height);\n\n    this._$dateTable.height(height);\n\n    this.callBase();\n  },\n  _getWorkSpaceMinHeight: function _getWorkSpaceMinHeight() {\n    var minHeight = this._getWorkSpaceHeight();\n\n    var workspaceContainerHeight = this.$element().outerHeight(true) - this.getHeaderPanelHeight() - 2 * DATE_TABLE_CELL_BORDER - DATE_TABLE_HEADER_MARGIN;\n\n    if (minHeight < workspaceContainerHeight) {\n      minHeight = workspaceContainerHeight;\n    }\n\n    return minHeight;\n  },\n  _makeGroupRows: function _makeGroupRows(groups, groupByDate) {\n    var tableCreatorStrategy = \"vertical\" === this.option(\"groupOrientation\") ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n    return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n      groupRowClass: this._getGroupRowClass(),\n      groupHeaderRowClass: this._getGroupRowClass(),\n      groupHeaderClass: this._getGroupHeaderClass.bind(this),\n      groupHeaderContentClass: this._getGroupHeaderContentClass()\n    }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getTotalRowCount(this._getGroupCount()), groupByDate);\n  },\n  _ensureGroupHeaderCellsHeight: function _ensureGroupHeaderCellsHeight(cellHeight) {\n    var minCellHeight = this._calculateMinCellHeight();\n\n    if (cellHeight < minCellHeight) {\n      return minCellHeight;\n    }\n\n    return cellHeight;\n  },\n  _calculateMinCellHeight: function _calculateMinCellHeight() {\n    var dateTable = this._getDateTable();\n\n    var dateTableRowSelector = \".\" + this._getDateTableRowClass();\n\n    return getBoundingRect(dateTable).height / dateTable.find(dateTableRowSelector).length - 2 * DATE_TABLE_CELL_BORDER;\n  },\n  _getCellCoordinatesByIndex: function _getCellCoordinatesByIndex(index) {\n    return {\n      cellIndex: index % this._getCellCount(),\n      rowIndex: 0\n    };\n  },\n  _getCellByCoordinates: function _getCellByCoordinates(cellCoordinates, groupIndex) {\n    var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);\n\n    return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.cellIndex);\n  },\n  _getWorkSpaceWidth: function _getWorkSpaceWidth() {\n    return this._$dateTable.outerWidth(true);\n  },\n  _getIndicationFirstViewDate: function _getIndicationFirstViewDate() {\n    return new Date(this._firstViewDate);\n  },\n  _getIntervalBetween: function _getIntervalBetween(currentDate, allDay) {\n    var startDayHour = this.option(\"startDayHour\");\n    var endDayHour = this.option(\"endDayHour\");\n    var firstViewDate = this.getStartViewDate();\n    var firstViewDateTime = firstViewDate.getTime();\n    var hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\");\n    var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n    var apptStart = currentDate.getTime();\n    var fullInterval = apptStart - firstViewDateTime - timeZoneOffset;\n    var fullDays = Math.floor(fullInterval / toMs(\"day\"));\n    var tailDuration = fullInterval - fullDays * toMs(\"day\");\n    var tailDelta = 0;\n\n    var cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays));\n\n    var gapBeforeAppt = apptStart - dateUtils.trimTime(new Date(currentDate)).getTime();\n    var result = cellCount * this.option(\"hoursInterval\") * toMs(\"hour\");\n\n    if (!allDay) {\n      if (currentDate.getHours() < startDayHour) {\n        tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;\n      } else {\n        if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {\n          tailDelta = tailDuration;\n        } else {\n          if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {\n            tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs(\"hour\"));\n          } else {\n            if (!fullDays) {\n              result = fullInterval;\n            }\n          }\n        }\n      }\n\n      result += tailDelta;\n    }\n\n    return result;\n  },\n  _getWeekendsCount: function _getWeekendsCount() {\n    return 0;\n  },\n  getAllDayContainer: function getAllDayContainer() {\n    return null;\n  },\n  getTimePanelWidth: function getTimePanelWidth() {\n    return 0;\n  },\n  getPositionShift: function getPositionShift(timeShift) {\n    var positionShift = this.callBase(timeShift);\n    var left = this.getCellWidth() * timeShift;\n\n    if (this.option(\"rtlEnabled\")) {\n      left *= -1;\n    }\n\n    left += positionShift.left;\n    return {\n      top: 0,\n      left: left,\n      cellPosition: left\n    };\n  },\n  getVisibleBounds: function getVisibleBounds() {\n    var isRtl = this.option(\"rtlEnabled\");\n    var result = {};\n    var $scrollable = this.getScrollable().$element();\n    var cellWidth = this.getCellWidth();\n    var scrollableOffset = isRtl ? this.getScrollableOuterWidth() - this.getScrollableScrollLeft() : this.getScrollableScrollLeft();\n    var scrolledCellCount = scrollableOffset / cellWidth;\n    var visibleCellCount = $scrollable.width() / cellWidth;\n    var totalCellCount = isRtl ? scrolledCellCount - visibleCellCount : scrolledCellCount + visibleCellCount;\n\n    var leftDate = this._getDateByIndex(scrolledCellCount);\n\n    var rightDate = this._getDateByIndex(totalCellCount);\n\n    if (isRtl) {\n      leftDate = this._getDateByIndex(totalCellCount);\n      rightDate = this._getDateByIndex(scrolledCellCount);\n    }\n\n    result.left = {\n      hours: leftDate.getHours(),\n      minutes: leftDate.getMinutes() >= 30 ? 30 : 0,\n      date: dateUtils.trimTime(leftDate)\n    };\n    result.right = {\n      hours: rightDate.getHours(),\n      minutes: rightDate.getMinutes() >= 30 ? 30 : 0,\n      date: dateUtils.trimTime(rightDate)\n    };\n    return result;\n  },\n  needUpdateScrollPosition: function needUpdateScrollPosition(hours, minutes, bounds, date) {\n    var isUpdateNeeded = false;\n    isUpdateNeeded = this._dateWithinBounds(bounds, date);\n\n    if (hours < bounds.left.hours || hours > bounds.right.hours) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.left.hours && minutes < bounds.left.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    if (hours === bounds.right.hours && minutes > bounds.right.minutes) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  getIntervalDuration: function getIntervalDuration(allDay) {\n    return this.getCellDuration();\n  },\n  _dateWithinBounds: function _dateWithinBounds(bounds, date) {\n    var trimmedDate = dateUtils.trimTime(new Date(date));\n    var isUpdateNeeded = false;\n\n    if (trimmedDate < bounds.left.date || trimmedDate > bounds.right.date) {\n      isUpdateNeeded = true;\n    }\n\n    return isUpdateNeeded;\n  },\n  _supportCompactDropDownAppointments: function _supportCompactDropDownAppointments() {\n    return false;\n  },\n  getCellMinWidth: function getCellMinWidth() {\n    return 0;\n  },\n  getWorkSpaceLeftOffset: function getWorkSpaceLeftOffset() {\n    return 0;\n  },\n  scrollToTime: function scrollToTime(hours, minutes, date) {\n    var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n    var scrollable = this.getScrollable();\n    var offset = this.option(\"rtlEnabled\") ? getBoundingRect(this.getScrollableContainer().get(0)).width : 0;\n\n    if (this.option(\"templatesRenderAsynchronously\")) {\n      setTimeout(function () {\n        scrollable.scrollBy({\n          left: coordinates.left - scrollable.scrollLeft() - offset,\n          top: 0\n        });\n      });\n    } else {\n      scrollable.scrollBy({\n        left: coordinates.left - scrollable.scrollLeft() - offset,\n        top: 0\n      });\n    }\n  },\n  _getRowCountWithAllDayRows: function _getRowCountWithAllDayRows() {\n    return this._getRowCount();\n  }\n});\nregisterComponent(\"dxSchedulerTimeline\", SchedulerTimeline);\nmodule.exports = SchedulerTimeline;","map":null,"metadata":{},"sourceType":"script"}