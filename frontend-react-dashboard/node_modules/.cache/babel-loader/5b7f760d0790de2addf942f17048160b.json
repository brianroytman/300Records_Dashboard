{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _position = require(\"../../../core/utils/position\");\n\nvar _uiSchedulerWork_spaceGrouped = require(\"./ui.scheduler.work_space.grouped.strategy\");\n\nvar _uiSchedulerWork_spaceGrouped2 = _interopRequireDefault(_uiSchedulerWork_spaceGrouped);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    _setPrototypeOf(subClass, superClass);\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var result,\n        Super = _getPrototypeOf(Derived);\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (\"object\" === _typeof(call) || \"function\" === typeof call)) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (\"undefined\" === typeof Reflect || !Reflect.construct) {\n    return false;\n  }\n\n  if (Reflect.construct.sham) {\n    return false;\n  }\n\n  if (\"function\" === typeof Proxy) {\n    return true;\n  }\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar HORIZONTAL_GROUPED_ATTR = \"dx-group-row-count\";\n\nvar HorizontalGroupedStrategy = function (_GroupedStrategy) {\n  _inherits(HorizontalGroupedStrategy, _GroupedStrategy);\n\n  var _super = _createSuper(HorizontalGroupedStrategy);\n\n  function HorizontalGroupedStrategy() {\n    _classCallCheck(this, HorizontalGroupedStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HorizontalGroupedStrategy, [{\n    key: \"prepareCellIndexes\",\n    value: function value(cellCoordinates, groupIndex, inAllDay) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      if (!groupByDay) {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          cellIndex: cellCoordinates.cellIndex + groupIndex * this._workSpace._getCellCount()\n        };\n      } else {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          cellIndex: cellCoordinates.cellIndex * this._workSpace._getGroupCount() + groupIndex\n        };\n      }\n    }\n  }, {\n    key: \"calculateCellIndex\",\n    value: function value(rowIndex, cellIndex) {\n      cellIndex %= this._workSpace._getCellCount();\n      return this._workSpace._getRowCount() * cellIndex + rowIndex;\n    }\n  }, {\n    key: \"getGroupIndex\",\n    value: function value(rowIndex, cellIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      var groupCount = this._workSpace._getGroupCount();\n\n      if (groupByDay) {\n        return cellIndex % groupCount;\n      } else {\n        return Math.floor(cellIndex / this._workSpace._getCellCount());\n      }\n    }\n  }, {\n    key: \"calculateHeaderCellRepeatCount\",\n    value: function value() {\n      return this._workSpace._getGroupCount() || 1;\n    }\n  }, {\n    key: \"insertAllDayRowsIntoDateTable\",\n    value: function value() {\n      return false;\n    }\n  }, {\n    key: \"getTotalCellCount\",\n    value: function value(groupCount) {\n      groupCount = groupCount || 1;\n      return this._workSpace._getCellCount() * groupCount;\n    }\n  }, {\n    key: \"getTotalRowCount\",\n    value: function value() {\n      return this._workSpace._getRowCount();\n    }\n  }, {\n    key: \"addAdditionalGroupCellClasses\",\n    value: function value(cellClass, index) {\n      cellClass = this._addLastGroupCellClass(cellClass, index);\n      return this._addFirstGroupCellClass(cellClass, index);\n    }\n  }, {\n    key: \"_addLastGroupCellClass\",\n    value: function value(cellClass, index) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      if (groupByDay) {\n        if (index % this._workSpace._getGroupCount() === 0) {\n          return cellClass + \" \" + this.getLastGroupCellClass();\n        }\n      } else {\n        if (index % this._workSpace._getCellCount() === 0) {\n          return cellClass + \" \" + this.getLastGroupCellClass();\n        }\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"_addFirstGroupCellClass\",\n    value: function value(cellClass, index) {\n      if ((index - 1) % this._workSpace._getCellCount() === 0) {\n        return cellClass + \" \" + this.getFirstGroupCellClass();\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"getHorizontalMax\",\n    value: function value(groupIndex) {\n      return this._workSpace.getMaxAllowedPosition()[groupIndex];\n    }\n  }, {\n    key: \"getVerticalMax\",\n    value: function value(groupIndex) {\n      return this._workSpace.getMaxAllowedVerticalPosition()[0];\n    }\n  }, {\n    key: \"calculateTimeCellRepeatCount\",\n    value: function value() {\n      return 1;\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function value() {\n      return (0, _position.getBoundingRect)(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function value() {\n      return this._workSpace.getAllDayHeight();\n    }\n  }, {\n    key: \"getAllDayTableHeight\",\n    value: function value() {\n      return (0, _position.getBoundingRect)(this._workSpace._$allDayTable.get(0)).height || 0;\n    }\n  }, {\n    key: \"getGroupCountAttr\",\n    value: function value(groupRowCount, groupRows) {\n      return {\n        attr: HORIZONTAL_GROUPED_ATTR,\n        count: groupRows && groupRows.elements.length\n      };\n    }\n  }, {\n    key: \"getLeftOffset\",\n    value: function value() {\n      return this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"getGroupBoundsOffset\",\n    value: function value(cellCount, $cells, cellWidth, coordinates) {\n      var groupIndex;\n      var cellIndex;\n      var startCellIndex;\n      var startOffset;\n      var endOffset;\n\n      if (this._workSpace.isGroupedByDate()) {\n        startCellIndex = 0;\n        startOffset = $cells.eq(startCellIndex).offset().left - cellWidth / 2;\n        endOffset = $cells.eq(cellCount * this._workSpace._getGroupCount() - 1).offset().left + cellWidth + cellWidth / 2;\n      } else {\n        cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n        groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n        startCellIndex = groupIndex * cellCount;\n        startOffset = $cells.eq(startCellIndex).offset().left - cellWidth / 2;\n        endOffset = $cells.eq(startCellIndex + cellCount - 1).offset().left + cellWidth + cellWidth / 2;\n      }\n\n      return {\n        left: startOffset,\n        right: endOffset,\n        top: 0,\n        bottom: 0\n      };\n    }\n  }, {\n    key: \"shiftIndicator\",\n    value: function value($indicator, height, rtlOffset, groupIndex) {\n      var offset = this._getIndicatorOffset(groupIndex);\n\n      var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n      $indicator.css(\"left\", horizontalOffset);\n      $indicator.css(\"top\", height);\n    }\n  }, {\n    key: \"_getIndicatorOffset\",\n    value: function value(groupIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);\n    }\n  }, {\n    key: \"_calculateOffset\",\n    value: function value(groupIndex) {\n      return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex;\n    }\n  }, {\n    key: \"_calculateGroupByDateOffset\",\n    value: function value(groupIndex) {\n      return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;\n    }\n  }, {\n    key: \"getShaderOffset\",\n    value: function value(i, width) {\n      var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\n      return this._workSpace.option(\"rtlEnabled\") ? (0, _position.getBoundingRect)(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;\n    }\n  }, {\n    key: \"getShaderTopOffset\",\n    value: function value(i) {\n      return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);\n    }\n  }, {\n    key: \"getShaderHeight\",\n    value: function value() {\n      var height = this._workSpace.getIndicationHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getShaderMaxHeight\",\n    value: function value() {\n      return (0, _position.getBoundingRect)(this._workSpace._dateTableScrollable.$content().get(0)).height;\n    }\n  }, {\n    key: \"getShaderWidth\",\n    value: function value(i) {\n      return this._workSpace.getIndicationWidth(i);\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function value(allDay) {\n      return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;\n    }\n  }, {\n    key: \"getGroupIndexByCell\",\n    value: function value($cell) {\n      var rowIndex = $cell.parent().index();\n      var cellIndex = $cell.index();\n      return this.getGroupIndex(rowIndex, cellIndex);\n    }\n  }]);\n\n  return HorizontalGroupedStrategy;\n}(_uiSchedulerWork_spaceGrouped2.default);\n\nmodule.exports = HorizontalGroupedStrategy;","map":null,"metadata":{},"sourceType":"script"}