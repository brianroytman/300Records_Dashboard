{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.vertical.js)\r\n * Version: 20.1.7\r\n * Build date: Tue Aug 25 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _position = require(\"../../../core/utils/position\");\n\nvar _uiSchedulerWork_spaceGrouped = require(\"./ui.scheduler.work_space.grouped.strategy\");\n\nvar _uiSchedulerWork_spaceGrouped2 = _interopRequireDefault(_uiSchedulerWork_spaceGrouped);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    _setPrototypeOf(subClass, superClass);\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var result,\n        Super = _getPrototypeOf(Derived);\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (\"object\" === _typeof(call) || \"function\" === typeof call)) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (\"undefined\" === typeof Reflect || !Reflect.construct) {\n    return false;\n  }\n\n  if (Reflect.construct.sham) {\n    return false;\n  }\n\n  if (\"function\" === typeof Proxy) {\n    return true;\n  }\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar VERTICAL_GROUPED_ATTR = \"dx-group-column-count\";\nvar DATE_HEADER_OFFSET = 10;\nvar WORK_SPACE_BORDER = 1;\n\nvar VerticalGroupedStrategy = function (_GroupedStrategy) {\n  _inherits(VerticalGroupedStrategy, _GroupedStrategy);\n\n  var _super = _createSuper(VerticalGroupedStrategy);\n\n  function VerticalGroupedStrategy() {\n    _classCallCheck(this, VerticalGroupedStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VerticalGroupedStrategy, [{\n    key: \"prepareCellIndexes\",\n    value: function value(cellCoordinates, groupIndex, inAllDayRow) {\n      var rowIndex = cellCoordinates.rowIndex + groupIndex * this._workSpace._getRowCount();\n\n      if (this._workSpace.supportAllDayRow() && this._workSpace.option(\"showAllDayPanel\")) {\n        rowIndex += groupIndex;\n\n        if (!inAllDayRow) {\n          rowIndex += 1;\n        }\n      }\n\n      return {\n        rowIndex: rowIndex,\n        cellIndex: cellCoordinates.cellIndex\n      };\n    }\n  }, {\n    key: \"calculateCellIndex\",\n    value: function value(rowIndex, cellIndex) {\n      rowIndex %= this._workSpace._getRowCount();\n      return this._workSpace._getRowCount() * cellIndex + rowIndex;\n    }\n  }, {\n    key: \"getGroupIndex\",\n    value: function value(rowIndex) {\n      return Math.floor(rowIndex / this._workSpace._getRowCount());\n    }\n  }, {\n    key: \"calculateHeaderCellRepeatCount\",\n    value: function value() {\n      return 1;\n    }\n  }, {\n    key: \"insertAllDayRowsIntoDateTable\",\n    value: function value() {\n      return this._workSpace.option(\"showAllDayPanel\");\n    }\n  }, {\n    key: \"getTotalCellCount\",\n    value: function value() {\n      return this._workSpace._getCellCount();\n    }\n  }, {\n    key: \"getTotalRowCount\",\n    value: function value() {\n      return this._workSpace._getRowCount() * this._workSpace._getGroupCount();\n    }\n  }, {\n    key: \"addAdditionalGroupCellClasses\",\n    value: function value(cellClass, index, i, j) {\n      cellClass = this._addLastGroupCellClass(cellClass, i + 1);\n      return this._addFirstGroupCellClass(cellClass, i + 1);\n    }\n  }, {\n    key: \"_addLastGroupCellClass\",\n    value: function value(cellClass, index) {\n      if (index % this._workSpace._getRowCount() === 0) {\n        return cellClass + \" \" + this.getLastGroupCellClass();\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"_addFirstGroupCellClass\",\n    value: function value(cellClass, index) {\n      if ((index - 1) % this._workSpace._getRowCount() === 0) {\n        return cellClass + \" \" + this.getFirstGroupCellClass();\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"getHorizontalMax\",\n    value: function value() {\n      return this._workSpace.getMaxAllowedPosition()[0];\n    }\n  }, {\n    key: \"getVerticalMax\",\n    value: function value(groupIndex) {\n      var maxAllowedPosition = this._workSpace.getMaxAllowedVerticalPosition()[groupIndex];\n\n      maxAllowedPosition += this._getOffsetByAllDayPanel(groupIndex);\n      return maxAllowedPosition;\n    }\n  }, {\n    key: \"_getOffsetByAllDayPanel\",\n    value: function value(groupIndex) {\n      var result = 0;\n\n      if (this._workSpace.supportAllDayRow() && this._workSpace.option(\"showAllDayPanel\")) {\n        result = this._workSpace.getCellHeight() * (groupIndex + 1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getGroupTop\",\n    value: function value(groupIndex) {\n      return this._workSpace.getMaxAllowedVerticalPosition()[groupIndex] - this._workSpace.getCellHeight() * this._workSpace._getRowCount();\n    }\n  }, {\n    key: \"calculateTimeCellRepeatCount\",\n    value: function value() {\n      return this._workSpace._getGroupCount() || 1;\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function value() {\n      var minWidth = this._workSpace._getWorkSpaceWidth();\n\n      var workspaceContainerWidth = (0, _position.getBoundingRect)(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth() - this._workSpace.getGroupTableWidth() - 2 * WORK_SPACE_BORDER;\n\n      if (minWidth < workspaceContainerWidth) {\n        minWidth = workspaceContainerWidth;\n      }\n\n      return minWidth;\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"getAllDayTableHeight\",\n    value: function value() {\n      return 0;\n    }\n  }, {\n    key: \"getGroupCountAttr\",\n    value: function value() {\n      return {\n        attr: VERTICAL_GROUPED_ATTR,\n        count: this._workSpace.option(\"groups\") && this._workSpace.option(\"groups\").length\n      };\n    }\n  }, {\n    key: \"getLeftOffset\",\n    value: function value() {\n      return this._workSpace.getTimePanelWidth() + this._workSpace.getGroupTableWidth();\n    }\n  }, {\n    key: \"getGroupBoundsOffset\",\n    value: function value(cellCount, $cells, cellWidth, coordinates) {\n      var groupIndex = coordinates.groupIndex;\n      var startOffset = $cells.eq(0).offset().left;\n      var endOffset = $cells.eq(cellCount - 1).offset().left + cellWidth;\n\n      var dayHeight = this._workSpace._calculateDayDuration() / this._workSpace.option(\"hoursInterval\") * this._workSpace.getCellHeight();\n\n      var scrollTop = this.getScrollableScrollTop();\n      var topOffset = groupIndex * dayHeight + (0, _position.getBoundingRect)(this._workSpace._$thead.get(0)).height + this._workSpace.invoke(\"getHeaderHeight\") + DATE_HEADER_OFFSET - scrollTop;\n\n      if (this._workSpace.option(\"showAllDayPanel\") && this._workSpace.supportAllDayRow()) {\n        topOffset += this._workSpace.getCellHeight() * (groupIndex + 1);\n      }\n\n      var bottomOffset = topOffset + dayHeight;\n      return {\n        left: startOffset,\n        right: endOffset,\n        top: topOffset,\n        bottom: bottomOffset\n      };\n    }\n  }, {\n    key: \"shiftIndicator\",\n    value: function value($indicator, height, rtlOffset, i) {\n      var offset = this._workSpace.getIndicatorOffset(0);\n\n      var tableOffset = this._workSpace.option(\"crossScrollingEnabled\") ? 0 : this._workSpace.getGroupTableWidth();\n      var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n      var verticalOffset = this._workSpace._getRowCount() * this._workSpace.getCellHeight() * i;\n\n      if (this._workSpace.supportAllDayRow() && this._workSpace.option(\"showAllDayPanel\")) {\n        verticalOffset += this._workSpace.getAllDayHeight() * (i + 1);\n      }\n\n      $indicator.css(\"left\", horizontalOffset + tableOffset);\n      $indicator.css(\"top\", height + verticalOffset);\n    }\n  }, {\n    key: \"getShaderOffset\",\n    value: function value(i, width) {\n      var offset = this._workSpace.option(\"crossScrollingEnabled\") ? 0 : this._workSpace.getGroupTableWidth();\n      return this._workSpace.option(\"rtlEnabled\") ? (0, _position.getBoundingRect)(this._$container.get(0)).width - offset - this._workSpace.getWorkSpaceLeftOffset() - width : offset;\n    }\n  }, {\n    key: \"getShaderTopOffset\",\n    value: function value(i) {\n      return 0;\n    }\n  }, {\n    key: \"getShaderHeight\",\n    value: function value() {\n      var height = this._workSpace.getIndicationHeight();\n\n      if (this._workSpace.supportAllDayRow() && this._workSpace.option(\"showAllDayPanel\")) {\n        height += this._workSpace.getCellHeight();\n      }\n\n      return height;\n    }\n  }, {\n    key: \"getShaderMaxHeight\",\n    value: function value() {\n      var height = this._workSpace._getRowCount() * this._workSpace.getCellHeight();\n\n      if (this._workSpace.supportAllDayRow() && this._workSpace.option(\"showAllDayPanel\")) {\n        height += this._workSpace.getCellHeight();\n      }\n\n      return height;\n    }\n  }, {\n    key: \"getShaderWidth\",\n    value: function value() {\n      return this._workSpace.getIndicationWidth(0);\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function value() {\n      return this._workSpace.getScrollable().scrollTop();\n    }\n  }, {\n    key: \"getGroupIndexByCell\",\n    value: function value($cell) {\n      var rowIndex = $cell.parent().index();\n\n      var rowCount = this._workSpace._getRowCountWithAllDayRows();\n\n      return Math.ceil((rowIndex + 1) / rowCount);\n    }\n  }]);\n\n  return VerticalGroupedStrategy;\n}(_uiSchedulerWork_spaceGrouped2.default);\n\nmodule.exports = VerticalGroupedStrategy;","map":null,"metadata":{},"sourceType":"script"}